<div class="article-inner">
 <header>
  <div class="entry-meta beforetitle-meta">
  </div>
  <h1 class="entry-title singular-title" itemprop="headline">
   A.4 — C++ FAQ
  </h1>
  <div class="entry-meta aftertitle-meta">
  </div>
 </header>
 <div class="entry-content" itemprop="articleBody">
  <p>
   <br/>
   There are certain questions that tend to get asked over and over. This FAQ will attempt to answer the most common ones.
   <p class="cpp-section cpp-topline" style="clear:both">
    <a name="usingnamespace">
    </a>
    Q1: Why shouldn’t we use “using namespace std”?
    <a href="#usingnamespace">
     <i class="fa fa-link" style="font-size:.8em">
     </i>
    </a>
    <p>
     The statement
     <code>
      using namespace std;
     </code>
     is a
     <strong>
      using directive
     </strong>
     . A using-directive allows all of the identifiers from a given namespace to be accessed within the scope of the using-directive statement.
     <p>
      You may have seen something like this:
      <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

using namespace std;

int main()
{
    cout &lt;&lt; "Hello world!";

    return 0;
}</code></pre>
      <p>
       This allows us to use names from the
       <code>
        std
       </code>
       namespace without having to explicitly type
       <code>
        std::
       </code>
       over and over. In the above program, we can just type
       <code>
        cout
       </code>
       instead of
       <code>
        std::cout
       </code>
       . Sounds great, right?
       <p>
        However, when the compiler encounters
        <code>
         using namespace std
        </code>
        , it will make every single identifier in the
        <code>
         std
        </code>
        namespace available from the global scope (since that’s where the using directive has been placed). This introduces 3 key challenges:
        <ul>
         <li>
          The chance for a naming collision between a name you’ve picked and something that already exists in the
          <code>
           std
          </code>
          namespace is massively increased.
          <li>
           New versions of the standard library may break your currently working program. These future versions could introduce names that cause new naming collisions, or in the worst case, the behavior of your program might change silently and unexpectedly!
           <li>
            The lack of
            <code>
             std::
            </code>
            prefixes makes it harder for readers to understand what is a
            <code>
             std
            </code>
            library name and what is a user-defined name.
           </li>
          </li>
         </li>
        </ul>
        <p>
         For these reasons, we recommend avoiding
         <code>
          using namespace std
         </code>
         (or any other using-directive) entirely. The small savings in typing isn’t worth the additional headaches and future risks.
         <div class="cpp-note cpp-lightgraybackground">
          <p class="cpp-note-title cpp-bottomline">
           Related content
           <p>
            See lesson
            <a href="https://www.learncpp.com/cpp-tutorial/using-declarations-and-using-directives/">
             7.13 -- Using declarations and using directives
            </a>
            for more detail and examples.
           </p>
          </p>
         </div>
         <p class="cpp-section cpp-topline" style="clear:both">
          <a name="transitiveInclude">
          </a>
          Q2: Why can I use some function or type without including the header that declares that function or type?
          <a href="#transitiveInclude">
           <i class="fa fa-link" style="font-size:.8em">
           </i>
          </a>
          <p>
           For example, many readers ask why their program that uses
           <code>
            std::string_view
           </code>
           needs to
           <code>
            #include &lt;string_view&gt;
           </code>
           when it seems to work fine without the #include.
           <p>
            Headers can #include other headers. When you #include a header, you also get all of the additional headers that it includes (and all of the headers that those headers include too). All of the additional headers that come along for the ride that you didn’t explicitly include are called “transitive includes”.
            <p>
             In your
             <em>
              main.cpp
             </em>
             file, you probably
             <code>
              #include &lt;iostream&gt;
             </code>
             . On your compiler, if your &lt;iostream&gt; header includes the &lt;string_view&gt; header (for its own use), then when you
             <code>
              #include &lt;iostream&gt;
             </code>
             you will get the contents of the &lt;string_view&gt; header (and any other headers that &lt;iostream&gt; includes). This means your
             <em>
              main.cpp
             </em>
             will be able to use the
             <code>
              std::string_view
             </code>
             type without explicitly including &lt;string_view&gt; header.
             <p>
              Even though this may compile on your compiler, you should not rely on this. What compiles for you now may not compile on another compiler, or even on a future version of your compiler.
              <p>
               There is no way to warn when this happens, or prevent it from happening. The best you can do is take care to explicitly include the proper headers for all of the things you use. Compiling your program on several different compilers may help identify headers that are being transitively included on other compilers.
               <div class="cpp-note cpp-lightgraybackground">
                <p class="cpp-note-title cpp-bottomline">
                 Related content
                 <p>
                  Covered in lesson
                  <a href="https://www.learncpp.com/cpp-tutorial/header-files/">
                   2.11 -- Header files
                  </a>
                  .
                 </p>
                </p>
               </div>
               <p class="cpp-section cpp-topline" style="clear:both">
                <a name="undefinedbehavior">
                </a>
                Q3: My code that produces undefined behavior appears to be working fine. Is this okay?
                <a href="#undefinedbehavior">
                 <i class="fa fa-link" style="font-size:.8em">
                 </i>
                </a>
                <p>
                 aka: “I did that thing you told me not to do, and it worked. So what’s the issue?”
                 <p>
                  Undefined behavior occurs when you perform an operation whose behavior is not defined by the C++ language. Code implementing undefined behavior may exhibit
                  <em>
                   any
                  </em>
                  of the following symptoms:
                  <ul>
                   <li>
                    Your program produces a different result every time it is run.
                    <li>
                     Your program behaves inconsistently (sometimes produces the desired result, sometimes not).
                     <li>
                      Your program consistently produces the same incorrect result.
                      <li>
                       Your program initially seems like its working but produces some incorrect result later in the program.
                       <li>
                        Your program crashes, either immediately or later.
                        <li>
                         Your program works on some compilers or platforms but not others.
                         <li>
                          Your program works until you change some other seemingly unrelated code.
                          <li>
                           Your program appears to produce the desired result anyway.
                          </li>
                         </li>
                        </li>
                       </li>
                      </li>
                     </li>
                    </li>
                   </li>
                  </ul>
                  <p>
                   One of the biggest problems with undefined behavior is that the behavior exhibited by the program may change at any point, for any reason. So while such code may appear to work now, there is no guarantee it will do so when run again later.
                   <div class="cpp-note cpp-lightgraybackground">
                    <p class="cpp-note-title cpp-bottomline">
                     Related content
                     <p>
                      Undefined behavior is covered in lesson
                      <a href="https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/">
                       1.6 -- Uninitialized variables and undefined behavior
                      </a>
                      .
                     </p>
                    </p>
                   </div>
                   <p class="cpp-section cpp-topline" style="clear:both">
                    <a name="howundefinedworks">
                    </a>
                    Q4: Why does my code that produces undefined behavior generate a certain result?
                    <a href="#howundefinedworks">
                     <i class="fa fa-link" style="font-size:.8em">
                     </i>
                    </a>
                    <p>
                     Readers often ask what is happening to produce a specific result on their system. In most cases, it’s difficult to say, as the result produced may be dependent upon the current program state, your compiler settings, how the compiler implements a feature, the computer’s architecture, and/or the operating system. For example, if you print the value of an uninitialized variable, you might get garbage, or you might always get a particular value. It depends on what type of variable it is, how the compiler lays out the variable in memory, and what’s in that memory beforehand (which might be impacted by the OS or the state of the program prior to that point).
                     <p>
                      And while such an answer may be interesting mechanically, it’s rarely useful overall (and likely to change if and when anything else changes). It’s like asking, “When I put my seat belt through the steering wheel and connect it to the accelerator, why does the car pull left when I turn my head on a rainy day?” The best answer isn’t a physical explanation of what’s occurring, it’s “don’t do that”.
                      <p class="cpp-section cpp-topline" style="clear:both">
                       <a name="languagestandard">
                       </a>
                       Q5: Why am I getting a compile error when I try to compile an example that seems like it should work?
                       <a href="#languagestandard">
                        <i class="fa fa-link" style="font-size:.8em">
                        </i>
                       </a>
                       <p>
                        The most common reason for this is that your project is being compiled using the wrong language standard.
                        <p>
                         C++ introduces many new features with each new language standard. If one of our examples uses a feature that was introduced in C++17, but your program is compiling using the C++14 language standard, then it probably won’t compile because the feature we’re using isn’t supported by the language standard we’ve selected.
                         <p>
                          Try setting your language standard to the latest version your compiler supports and see if that resolves the issue. You can also check that your compiler is properly configured to use the language standard you’re expecting by running the program here:
                          <a href="https://www.learncpp.com/cpp-tutorial/what-language-standard-is-my-compiler-using/">
                           0.13 -- What language standard is my compiler using?
                          </a>
                          .
                          <div class="cpp-note cpp-lightgraybackground">
                           <p class="cpp-note-title cpp-bottomline">
                            Related content
                            <p>
                             Covered in lesson
                             <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-choosing-a-language-standard/">
                              0.12 -- Configuring your compiler: Choosing a language standard
                             </a>
                             .
                            </p>
                           </p>
                          </div>
                          <p>
                           It is also possible that your compiler either doesn’t support a specific feature yet, or has a bug preventing use in some cases. In this case, try updating your compiler to the latest version available.
                           <p>
                            The CPPReference website tracks compiler support for each feature per language standard. You can find those support tables linked from their
                            <a href="https://en.cppreference.com/w/cpp">
                             home page
                            </a>
                            , top right, under “Compiler Support” (by language standard). For example, you can see which C++23 features are supported
                            <a href="https://en.cppreference.com/w/cpp/compiler_support/23">
                             here
                            </a>
                            .
                            <p class="cpp-section cpp-topline" style="clear:both">
                             <a name="pairedheader">
                             </a>
                             Q6: Why should I #include “foo.h” from foo.cpp?
                             <a href="#pairedheader">
                              <i class="fa fa-link" style="font-size:.8em">
                              </i>
                             </a>
                             <p>
                              It is a best practice for a source file (e.g. foo.cpp) to include its paired header (e.g. foo.h). In many cases, foo.h will contain definitions that foo.cpp will need to compile correctly.
                              <p>
                               However, even if foo.cpp compiles file without foo.h, including the paired header allows the compiler to discover certain types of inconsistencies between the two files (e.g. when the return type of a function doesn’t match the return type of its forward declaration). Without the inclusion, this might cause undefined behavior.
                               <p>
                                The cost of the #include is negligible, so there is little downside to including the header.
                                <div class="cpp-note cpp-lightgraybackground">
                                 <p class="cpp-note-title cpp-bottomline">
                                  Related content
                                  <p>
                                   Covered in lesson
                                   <a href="https://www.learncpp.com/cpp-tutorial/header-files/#corresponding_include">
                                    2.11 -- Header files
                                   </a>
                                   .
                                  </p>
                                 </p>
                                </div>
                                <p class="cpp-section cpp-topline" style="clear:both">
                                 <a name="includecpp">
                                 </a>
                                 Q7: Why does my project only compile when I #include “foo.cpp” from “main.cpp”?
                                 <a href="#includecpp">
                                  <i class="fa fa-link" style="font-size:.8em">
                                  </i>
                                 </a>
                                 <p>
                                  This is almost always due to forgetting to add foo.cpp to your project and/or compilation command line. Update your project and/or command line to include each source (.cpp) file. When you compile your project, you should see each source file being compiled.
                                  <p>
                                   Normally in a project that has multiple files, the compiler will compile each source (.cpp) file individually. After all the source files have been compiled, the linker links them together and creates the resulting output file (e.g. an executable). However, if you split your code between two or more files (e.g. main.cpp and foo.cpp) and then only compiles main.cpp, you will probably get a compilation error or linker error, since part of the code required for your project is not being compiled.
                                   <p>
                                    New programmers sometimes discover that they can make their program work by adding
                                    <code>
                                     #include "foo.cpp"
                                    </code>
                                    to main.cpp instead of adding foo.cpp to the project or compilation command line. After doing so, when main.cpp is compiled, the will preprocessor will create a translation unit consisting of the code from both foo.cpp and main.cpp, which will then be compiled and linked. In smaller project, this may work. So why not do this?
                                    <p>
                                     There are a few reasons:
                                     <ol start="1">
                                      <li>
                                       It can result in naming collisions between files.
                                       <li>
                                        It can be hard to avoid ODR violations.
                                        <li>
                                         Any change to any .cpp file will result in your entire project being recompiled. This can take a long time.
                                        </li>
                                       </li>
                                      </li>
                                     </ol>
                                     <div class="cpp-note cpp-lightgraybackground">
                                      <p class="cpp-note-title cpp-bottomline">
                                       Related content
                                       <p>
                                        Covered in lesson
                                        <a href="https://www.learncpp.com/cpp-tutorial/header-files/#includecpp">
                                         2.11 -- Header files
                                        </a>
                                        .
                                       </p>
                                      </p>
                                     </div>
                                     <p class="cpp-section cpp-topline" style="clear:both">
                                      <a name="reteurnzero">
                                      </a>
                                      Q8: Why do I need to
                                      <code>
                                       return 0
                                      </code>
                                      at the bottom of main?
                                      <a href="#reteurnzero">
                                       <i class="fa fa-link" style="font-size:.8em">
                                       </i>
                                      </a>
                                      <p>
                                       You don’t. The
                                       <code>
                                        main()
                                       </code>
                                       function is special in that it will implicitly return 0 if you do not provide a return statement.
                                       <p>
                                        However, any other value-returning function that reaches the end of its body without encountering a return statement will produce undefined behavior.
                                        <p>
                                         For consistency, we recommend explicitly returning 0 from
                                         <code>
                                          main()
                                         </code>
                                         . But if you prefer to omit the return statement in
                                         <code>
                                          main()
                                         </code>
                                         for conciseness, you can. Just don’t make the mistake of thinking other value-returning functions work similarly.
                                         <div class="cpp-note cpp-lightgraybackground">
                                          <p class="cpp-note-title cpp-bottomline">
                                           Related content
                                           <p>
                                            Covered in lesson
                                            <a href="https://www.learncpp.com/cpp-tutorial/function-return-values-value-returning-functions/">
                                             2.2 -- Function return values (value-returning functions)
                                            </a>
                                            .
                                           </p>
                                          </p>
                                         </div>
                                         <p class="cpp-section cpp-topline" style="clear:both">
                                          <a name="CTAD">
                                          </a>
                                          Q9: When I compile an example from this website, I get an error similar to “argument list for class template XXX is missing”. Why?
                                          <a href="#CTAD">
                                           <i class="fa fa-link" style="font-size:.8em">
                                           </i>
                                          </a>
                                          <p>
                                           The most likely reason is that the example makes use of a feature called Class Template Argument Deduction (CTAD), which is a C++17 feature. Many compilers default to C++14, which doesn’t support this feature.
                                           <p>
                                            If the following program doesn’t compile for you, that’s the reason:
                                            <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;utility&gt; // for std::pair

int main()
{
    std::pair p2{ 1, 2 }; // CTAD used to deduce std::pair&lt;int, int&gt; from the initializers (C++17)

    return 0;
}</code></pre>
                                            <div class="cpp-note cpp-lightgraybackground">
                                             <p class="cpp-note-title cpp-bottomline">
                                              Related content
                                              <p>
                                               You can check which language standard your compiler is configured for using the program in lesson
                                               <a href="https://www.learncpp.com/cpp-tutorial/what-language-standard-is-my-compiler-using/">
                                                0.13 -- What language standard is my compiler using?
                                               </a>
                                               .
                                               <p>
                                                We cover CTAD in lesson
                                                <a href="https://www.learncpp.com/cpp-tutorial/class-template-argument-deduction-ctad-and-deduction-guides/">
                                                 13.14 -- Class template argument deduction (CTAD) and deduction guides
                                                </a>
                                                .
                                               </p>
                                              </p>
                                             </p>
                                            </div>
                                            <p class="cpp-section cpp-topline" style="clear:both">
                                             <a name="constbyvalue">
                                             </a>
                                             Q10: Why don’t we make function parameters or return types const when passing or returning by value?
                                             <a href="#constbyvalue">
                                              <i class="fa fa-link" style="font-size:.8em">
                                              </i>
                                             </a>
                                             <p>
                                              We typically don’t
                                              <code>
                                               const
                                              </code>
                                              by-value function parameters because:
                                              <ul>
                                               <li>
                                                Making such parameters
                                                <code>
                                                 const
                                                </code>
                                                offers no meaningful value to the caller of the function, but adds clutter to the function’s interface.
                                                <li>
                                                 We generally don’t care if the function modifies those parameters, since they are copies that will be destroyed at the end of the function anyway.
                                                </li>
                                               </li>
                                              </ul>
                                              <p>
                                               We don’t
                                               <code>
                                                const
                                               </code>
                                               by-value return values because:
                                               <ul>
                                                <li>
                                                 If the return type is a non-class-type (e.g. a fundamental type), const will be ignored anyway.
                                                 <li>
                                                  If the return type is a class type, const may inhibits certain kinds of optimizations (e.g. move semantics).
                                                 </li>
                                                </li>
                                               </ul>
                                               <p>
                                                Note:
                                                <code>
                                                 const
                                                </code>
                                                is relevant when passing/returning by address or by reference.
                                                <div class="cpp-note cpp-lightgraybackground">
                                                 <p class="cpp-note-title cpp-bottomline">
                                                  Related content
                                                  <p>
                                                   Covered in lesson
                                                   <a href="https://www.learncpp.com/cpp-tutorial/constant-variables-named-constants/">
                                                    5.1 -- Constant variables (named constants)
                                                   </a>
                                                  </p>
                                                 </p>
                                                </div>
                                                <p class="cpp-section cpp-topline" style="clear:both">
                                                 <a name="whyconstexpr">
                                                 </a>
                                                 Q11: Why should I use constexpr?
                                                 <a href="#whyconstexpr">
                                                  <i class="fa fa-link" style="font-size:.8em">
                                                  </i>
                                                 </a>
                                                 <p>
                                                  Constexpr and other compile-time programming techniques provide many benefits, including:
                                                  <ul>
                                                   <li>
                                                    Smaller and faster code.
                                                    <li>
                                                     We can have the compiler detect certain kinds of errors and halt compilation if they occur.
                                                     <li>
                                                      Undefined behavior is not allowed at compile-time.
                                                      <li>
                                                       The ability to use variables and functions in places that require a constant expression.
                                                      </li>
                                                     </li>
                                                    </li>
                                                   </li>
                                                  </ul>
                                                  <p>
                                                   The last point is perhaps the most unavoidable, as certain C++ features require values that are known at compile-time.
                                                   <div class="cpp-note cpp-lightgraybackground">
                                                    <p class="cpp-note-title cpp-bottomline">
                                                     Related content
                                                     <p>
                                                      Covered in lesson
                                                      <a href="https://www.learncpp.com/cpp-tutorial/constant-expressions/">
                                                       5.5 -- Constant expressions
                                                      </a>
                                                     </p>
                                                    </p>
                                                   </div>
                                                   <p class="cpp-section cpp-topline" style="clear:both">
                                                    <a name="constexprruntimeeval">
                                                    </a>
                                                    Q12: Why should I constexpr a function that I know will only be evaluated at runtime in my program?
                                                    <a href="#constexprruntimeeval">
                                                     <i class="fa fa-link" style="font-size:.8em">
                                                     </i>
                                                    </a>
                                                    <p>
                                                     There are a few reasons:
                                                     <ol start="1">
                                                      <li>
                                                       There’s little downside to using constexpr, and it may help the compiler optimize.
                                                       <li>
                                                        Just because you’re not calling the function in a compile-time evaluatable context right now doesn’t mean you won’t call it in such a context when you modify or extend your program. And if you haven’t constexpr’d the function already, you may not think to when you do start to call it in such a context, and then you’ll miss out on the performance benefits. Or you may be forced to constexpr it later when you need to use the return value in a context that requires a constant expression somewhere.
                                                        <li>
                                                         Repetition helps ingrain best practices.
                                                        </li>
                                                       </li>
                                                      </li>
                                                     </ol>
                                                     <p>
                                                      On a non-trivial project, it’s a good idea to implement your functions with the mindset that they may be reused (or extended) in the future. Any time you modify an existing function, you risk breaking it, and that means it needs to be retested, which takes time and energy. It’s often worth spending an extra minute or two “doing it right the first time” so you don’t have to redo (and retest) it again later.
                                                      <div class="cpp-note cpp-lightgraybackground">
                                                       <p class="cpp-note-title cpp-bottomline">
                                                        Related content
                                                        <p>
                                                         Covered in lesson
                                                         <a href="https://www.learncpp.com/cpp-tutorial/constexpr-functions/#constexprruntimeeval">
                                                          F.1 -- Constexpr functions
                                                         </a>
                                                        </p>
                                                       </p>
                                                      </div>
                                                      <p class="cpp-section cpp-topline" style="clear:both">
                                                       <a name="unspecifiedevaluationorder">
                                                       </a>
                                                       Q13: Why shouldn’t I call the same input function more than once in an expression?
                                                       <a href="#unspecifiedevaluationorder">
                                                        <i class="fa fa-link" style="font-size:.8em">
                                                        </i>
                                                       </a>
                                                       <p>
                                                        In most cases, the C++ standard does not specify the order in which operands (including function arguments) are evaluated. The precedence and associativity of operators is used only to determine how operands are grouped with operators, and the order of value computation.
                                                        <p>
                                                         For example, given the statement
                                                         <code>
                                                          std::cout &lt;&lt; subtract(getUserInput(), getUserInput())
                                                         </code>
                                                         , either the left argument or the right argument in the function call to
                                                         <code>
                                                          subtract()
                                                         </code>
                                                         could be evaluated first. Let’s say the user inputs the values
                                                         <code>
                                                          5
                                                         </code>
                                                         and
                                                         <code>
                                                          2
                                                         </code>
                                                         . If the left argument was evaluated first, the left argument will evaluate to
                                                         <code>
                                                          5
                                                         </code>
                                                         , and the right argument will evaluate to
                                                         <code>
                                                          2
                                                         </code>
                                                         .
                                                         <code>
                                                          5 - 2
                                                         </code>
                                                         is
                                                         <code>
                                                          3
                                                         </code>
                                                         . If the right argument was evaluated first, the right argument will evaluate to
                                                         <code>
                                                          5
                                                         </code>
                                                         , and the left argument will evaluate to
                                                         <code>
                                                          2
                                                         </code>
                                                         .
                                                         <code>
                                                          2 - 5
                                                         </code>
                                                         is
                                                         <code>
                                                          -3
                                                         </code>
                                                         . Thus, this statement might print either
                                                         <code>
                                                          3
                                                         </code>
                                                         or
                                                         <code>
                                                          -3
                                                         </code>
                                                         .
                                                         <p>
                                                          This can be disambiguated by making each function call to
                                                          <code>
                                                           getUserInput()
                                                          </code>
                                                          a separate statement (so the order is deterministic), and storing the return value in a variable until it is needed.
                                                          <div class="cpp-note cpp-lightgraybackground">
                                                           <p class="cpp-note-title cpp-bottomline">
                                                            Related content
                                                            <p>
                                                             Covered in lesson
                                                             <a href="https://www.learncpp.com/cpp-tutorial/operator-precedence-and-associativity/#unspecified">
                                                              6.1 -- Operator precedence and associativity
                                                             </a>
                                                            </p>
                                                           </p>
                                                          </div>
                                                         </p>
                                                        </p>
                                                       </p>
                                                      </p>
                                                     </p>
                                                    </p>
                                                   </p>
                                                  </p>
                                                 </p>
                                                </p>
                                               </p>
                                              </p>
                                             </p>
                                            </p>
                                           </p>
                                          </p>
                                         </p>
                                        </p>
                                       </p>
                                      </p>
                                     </p>
                                    </p>
                                   </p>
                                  </p>
                                 </p>
                                </p>
                               </p>
                              </p>
                             </p>
                            </p>
                           </p>
                          </p>
                         </p>
                        </p>
                       </p>
                      </p>
                     </p>
                    </p>
                   </p>
                  </p>
                 </p>
                </p>
               </p>
              </p>
             </p>
            </p>
           </p>
          </p>
         </p>
        </p>
       </p>
      </p>
     </p>
    </p>
   </p>
  </p>
 </div>
</div>
