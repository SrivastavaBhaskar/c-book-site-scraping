<div class="article-inner">
 <header>
  <div class="entry-meta beforetitle-meta">
  </div>
  <h1 class="entry-title singular-title" itemprop="headline">
   1.4 — Variable assignment and initialization
  </h1>
  <div class="entry-meta aftertitle-meta">
  </div>
 </header>
 <div class="entry-content" itemprop="articleBody">
  <p>
   In the previous lesson (
   <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-objects-and-variables/">
    1.3 -- Introduction to objects and variables
   </a>
   ), we covered how to define a variable that we can use to store values. In this lesson, we’ll explore how to actually put values into variables.
   <p>
    As a reminder, here’s a short program that first allocates a single integer variable named
    <code>
     x
    </code>
    , then allocates two more integer variables named
    <code>
     y
    </code>
    and
    <code>
     z
    </code>
    :
    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int main()
{
    int x;    // define an integer variable named x
    int y, z; // define two integer variables, named y and z

    return 0;
}</code></pre>
    <p class="cpp-section cpp-topline" style="clear:both">
     Variable assignment
     <p>
      After a variable has been defined, you can give it a value (in a separate statement) using the
      <code>
       =
      </code>
      operator. This process is called
      <strong>
       assignment
      </strong>
      , and the
      <code>
       =
      </code>
      operator is called the
      <strong>
       assignment operator
      </strong>
      .
      <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int width; // define an integer variable named width
width = 5; // assignment of value 5 into variable width

// variable width now has value 5</code></pre>
      <p>
       By default, assignment copies the value on the right-hand side of the
       <em>
        = operator
       </em>
       to the variable on the left-hand side of the operator. This is called
       <strong>
        copy-assignment
       </strong>
       .
       <p>
        Once a variable has been given a value, the value of that variable can be printed via
        <code>
         std::cout
        </code>
        and the
        <code>
         &lt;&lt;
        </code>
        operator.
        <p>
         Assignment can be used whenever we want to change the value held by a variable. Here’s an example where we use assignment twice:
         <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
	int width; // define a variable named width
	width = 5; // copy assignment of value 5 into variable width

	std::cout &lt;&lt; width; // prints 5

	width = 7; // change value stored in variable width to 7

	std::cout &lt;&lt; width; // prints 7

	return 0;
}</code></pre>
         <p>
          This prints:
          <pre>57
</pre>
          <p>
           When this program is run, execution begins at the top of the
           <code>
            main
           </code>
           function and proceeds sequentially. First, memory for variable
           <code>
            width
           </code>
           is allocated. We then assign
           <code>
            width
           </code>
           the value
           <code>
            5
           </code>
           . When we output the value of
           <code>
            width
           </code>
           , it prints
           <code>
            5
           </code>
           to the console. When we then assign value
           <code>
            7
           </code>
           to
           <code>
            width
           </code>
           , any prior value (in this case
           <code>
            5
           </code>
           ) is overwritten. Thus when we output
           <code>
            width
           </code>
           again, this time it prints
           <code>
            7
           </code>
           .
           <p>
            Normal variables can only hold one value at a time.
            <div class="cpp-note cpp-lightredbackground">
             <p class="cpp-note-title cpp-bottomline">
              Warning
              <p>
               One of the most common mistakes that new programmers make is to confuse the assignment operator (
               <code>
                =
               </code>
               ) with the equality operator (
               <code>
                ==
               </code>
               ). Assignment (
               <code>
                =
               </code>
               ) is used to assign a value to a variable. Equality (
               <code>
                ==
               </code>
               ) is used to test whether two operands are equal in value.
              </p>
             </p>
            </div>
            <p class="cpp-section cpp-topline" style="clear:both">
             Variable initialization
             <p>
              One downside of assignment is that assigning a value to a just-defined object requires two statements: one to define the variable, and another to assign the value.
              <p>
               These two steps can be combined. When an object is defined, you can optionally provide an initial value for the object. The process of specifying an initial value for an object is called
               <strong>
                initialization
               </strong>
               , and the syntax used to initialize an object is called an
               <strong>
                initializer
               </strong>
               . Informally, the initial value is often called an “initializer” as well.
               <p>
                For example, the following statement both defines a variable named
                <code>
                 width
                </code>
                (of type
                <code>
                 int
                </code>
                ) and initializes it with the value
                <code>
                 5
                </code>
                :
                <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    int width { 5 };    // define variable width and initialize with initial value 5
    std::cout &lt;&lt; width; // prints 5

    return 0;
}</code></pre>
                <p>
                 In the above initialization of variable
                 <code>
                  width
                 </code>
                 ,
                 <code>
                  { 5 }
                 </code>
                 is the initializer, and
                 <code>
                  5
                 </code>
                 is the initial value.
                 <div class="cpp-note cpp-lightbluebackground">
                  <p class="cpp-note-title cpp-bottomline">
                   Key insight
                   <p>
                    Initialization provides an initial value for a variable. Think “initial-ization”.
                   </p>
                  </p>
                 </div>
                 <p class="cpp-section cpp-topline" style="clear:both">
                  Different forms of initialization
                  <p>
                   Unlike assignment (which is generally straightforward), initialization in C++ is surprisingly complex. So we’ll present a simplified view here to get started.
                   <p>
                    There are 5 common forms of initialization in C++:
                    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int a;         // default-initialization (no initializer)

// Traditional initialization forms:
int b = 5;     // copy-initialization (initial value after equals sign)
int c ( 6 );   // direct-initialization (initial value in parenthesis)

// Modern initialization forms (preferred):
int d { 7 };   // direct-list-initialization (initial value in braces)
int e {};      // value-initialization (empty braces)</code></pre>
                    <p>
                     You may see the above forms written with different spacing (e.g.
                     <code>
                      int b=5;
                     </code>
                     <code>
                      int c(6);
                     </code>
                     ,
                     <code>
                      int d{7};
                     </code>
                     ,
                     <code>
                      int e{};
                     </code>
                     ). Whether you use extra spaces for readability or not is a matter of personal preference.
                     <p>
                      As of C++17, copy-initialization, direct-initialization, and direct-list-initialization behave identically in most cases. We’ll cover the most relevant case where they differ below.
                      <div class="cpp-note cpp-lightgraybackground">
                       <p class="cpp-note-title cpp-bottomline">
                        Related content
                        <p>
                         We cover the rest of the differences between copy-initialization, direct-initialization, and list-initialization in lesson
                         <a href="https://www.learncpp.com/cpp-tutorial/class-initialization-and-copy-elision/">
                          14.15 -- Class initialization and copy elision
                         </a>
                         .
                        </p>
                       </p>
                      </div>
                      <div class="cpp-note cpp-lightgraybackground">
                       <p class="cpp-note-title cpp-bottomline">
                        For advanced readers
                        <p>
                         Other forms of initialization include:
                         <ul>
                          <li>
                           Aggregate initialization (see
                           <a href="https://www.learncpp.com/cpp-tutorial/struct-aggregate-initialization/">
                            13.8 -- Struct aggregate initialization
                           </a>
                           ).
                           <li>
                            Copy-list-initialization (discussed below).
                            <li>
                             Reference initialization (see
                             <a href="https://www.learncpp.com/cpp-tutorial/lvalue-references/">
                              12.3 -- Lvalue references
                             </a>
                             ).
                             <li>
                              Static-initialization, constant-initialization, and dynamic-initialization (see
                              <a href="https://www.learncpp.com/cpp-tutorial/why-non-const-global-variables-are-evil/">
                               7.8 -- Why (non-const) global variables are evil
                              </a>
                              ).
                              <li>
                               Zero-initialization (discussed below).
                              </li>
                             </li>
                            </li>
                           </li>
                          </li>
                         </ul>
                        </p>
                       </p>
                      </div>
                      <p class="cpp-section cpp-topline" style="clear:both">
                       Default-initialization
                       <p>
                        When no initializer is provided (such as for variable
                        <code>
                         a
                        </code>
                        above), this is called
                        <strong>
                         default-initialization
                        </strong>
                        . In many cases, default-initialization performs no initialization, and leaves the variable with an indeterminate value (a value that is not predictable).
                        <p>
                         We’ll discuss this case further in lesson (
                         <a href="https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/">
                          1.6 -- Uninitialized variables and undefined behavior
                         </a>
                         ).
                         <p class="cpp-section cpp-topline" style="clear:both">
                          Copy-initialization
                          <p>
                           When an initial value is provided after an equals sign, this is called
                           <strong>
                            copy-initialization
                           </strong>
                           . This form of initialization was inherited from the C language.
                           <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int width = 5; // copy-initialization of value 5 into variable width</code></pre>
                           <p>
                            Much like copy-assignment, this copies the value on the right-hand side of the equals into the variable being created on the left-hand side. In the above snippet, variable
                            <code>
                             width
                            </code>
                            will be initialized with value
                            <code>
                             5
                            </code>
                            .
                            <p>
                             Copy-initialization had fallen out of favor in modern C++ due to being less efficient than other forms of initialization for some complex types. However, C++17 remedied the bulk of these issues, and copy-initialization is now finding new advocates. You will also find it used in older code (especially code ported from C), or by developers who simply think it looks more natural and is easier to read.
                             <div class="cpp-note cpp-lightgraybackground">
                              <p class="cpp-note-title cpp-bottomline">
                               For advanced readers
                               <p>
                                Copy-initialization is also used whenever values are implicitly copied, such as when passing arguments to a function by value, returning from a function by value, or catching exceptions by value.
                               </p>
                              </p>
                             </div>
                             <p class="cpp-section cpp-topline" style="clear:both">
                              Direct-initialization
                              <p>
                               When an initial value is provided inside parenthesis, this is called
                               <strong>
                                direct-initialization
                               </strong>
                               .
                               <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int width ( 5 ); // direct initialization of value 5 into variable width</code></pre>
                               <p>
                                Direct-initialization was initially introduced to allow for more efficient initialization of complex objects (those with class types, which we’ll cover in a future chapter). Just like copy-initialization, direct-initialization had fallen out of favor in modern C++, largely due to being superseded by direct-list-initialization. However, direct-list-initialization has a few quirks of its own, and so direct-initialization is once again finding use in certain cases.
                                <div class="cpp-note cpp-lightgraybackground">
                                 <p class="cpp-note-title cpp-bottomline">
                                  For advanced readers
                                  <p>
                                   Direct-initialization is also used when values are explicitly cast to another type (e.g. via
                                   <code>
                                    static_cast
                                   </code>
                                   ).
                                   <p>
                                    One of the reasons direct-initialization had fallen out of favor is because it makes it hard to differentiate variables from functions. For example:
                                    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int x();  // forward declaration of function x
int x(0); // definition of variable x with initializer 0
T(5);     // function call if T is a function, direct-initialization of temporary object if T is a type</code></pre>
                                   </p>
                                  </p>
                                 </p>
                                </div>
                                <p class="cpp-section cpp-topline" style="clear:both">
                                 Direct-list-initialization and copy-list-initialization
                                 <p>
                                  The modern way to initialize objects in C++ is to use a form of initialization that makes use of curly braces. This is called
                                  <strong>
                                   list-initialization
                                  </strong>
                                  (or
                                  <strong>
                                   uniform initialization
                                  </strong>
                                  or
                                  <strong>
                                   brace initialization
                                  </strong>
                                  ).
                                  <p>
                                   List-initialization comes in two forms:
                                   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int width { 5 };    // direct-list-initialization of initial value 5 into variable width (preferred)
int height = { 6 }; // copy-list-initialization of initial value 6 into variable height (rarely used)</code></pre>
                                   <p>
                                    Prior to the introduction of list-initialization, some types of initialization required using copy-initialization, and other types of initialization required using direct-initialization. Copy-initialization can be hard to differentiate from copy-assignment (because they both use an
                                    <code>
                                     =
                                    </code>
                                    ). And direct-initialization can be hard to differentiate from function-related operations (because they both use parenthesis).
                                    <p>
                                     List-initialization was introduced to provide a consistent initialization syntax (which is why it is sometimes called “uniform initialization”) that makes it clear we’re doing initialization.
                                     <div class="cpp-note cpp-lightbluebackground">
                                      <p class="cpp-note-title cpp-bottomline">
                                       Key insight
                                       <p>
                                        When we see curly braces, we know we’re creating and initializing an object.
                                       </p>
                                      </p>
                                     </div>
                                     <p>
                                      Additionally, list initialization provides a way to initialize objects with a list of values rather than a single value (which is why it is called “list initialization”). We show an example of this in lesson
                                      <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdvector-and-list-constructors/">
                                       16.2 -- Introduction to std::vector and list constructors
                                      </a>
                                      .
                                      <p class="cpp-section cpp-topline" style="clear:both">
                                       List initialization disallows narrowing conversions
                                       <p>
                                        The primary benefit of list-initialization is that “narrowing conversions” are disallowed. This means that if you try to list-initialize a variable using a value that the variable can not safely hold, the compiler is required to produce a diagnostic (compilation error or warning) to notify you. For example:
                                        <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int main()
{
    // An integer can only hold non-fractional values
    int w1 { 4.5 }; // compile error: list init does not allow narrowing conversion of 4.5 to 4

    int w2 = 4.5;   // compiles: copy-init initializes width with 4
    int w3 (4.5);    // compiles: direct-init initializes width with 4

    return 0;
}</code></pre>
                                        <p>
                                         On line 4 of the above program, we’re using a value (
                                         <code>
                                          4.5
                                         </code>
                                         ) with a fractional component (
                                         <code>
                                          .5
                                         </code>
                                         ) to list-initialize an integer variable (which can only hold non-fractional values). Because this is a narrowing conversion, the compiler is required to generate a diagnostic in such cases.
                                         <p>
                                          Copy-initialization (line 6) and direct-initialization (line 7) both silently drop the
                                          <code>
                                           .5
                                          </code>
                                          and initialize the variable with the value
                                          <code>
                                           4
                                          </code>
                                          (which probably isn’t what we want). Your compiler may warn you about this (since losing data is rarely desired), but it also may not.
                                          <p>
                                           Note that this restriction on narrowing conversions only applies to the list-initialization, not to any subsequent assignments to the variable:
                                           <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int main()
{
    int w1 { 4.5 }; // compile error: list-init does not allow narrowing conversion of 4.5 to 4

    w1 = 4.5;       // okay: copy-assignment allows narrowing conversion of 4.5 to 4

    return 0;
}</code></pre>
                                           <p class="cpp-section cpp-topline" style="clear:both">
                                            List-initialization is the preferred form of initialization in modern C++
                                            <div class="cpp-note cpp-lightbluebackground">
                                             <p class="cpp-note-title cpp-bottomline">
                                              Key insight
                                              <p>
                                               List-initialization is generally preferred over the other initialization forms because it works in most cases (and is therefore most consistent), it disallows narrowing conversions (which we normally don’t want), and it supports initialization with a list of values (something we’ll cover in a future lesson).
                                              </p>
                                             </p>
                                            </div>
                                            <div class="cpp-note cpp-lightgreenbackground">
                                             <p class="cpp-note-title cpp-bottomline">
                                              Best practice
                                              <p>
                                               Prefer direct-list-initialization when initializing your variables with one or more values.
                                              </p>
                                             </p>
                                            </div>
                                            <div class="cpp-note cpp-lightgraybackground">
                                             <p class="cpp-note-title cpp-bottomline">
                                              Author’s note
                                              <p>
                                               Bjarne Stroustrup (creator of C++) and Herb Sutter (C++ expert) also recommend
                                               <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-list">
                                                using list-initialization
                                               </a>
                                               to initialize your variables.
                                               <p>
                                                In modern C++, there are some cases where list-initialization does not work as expected. We cover one such case in lesson
                                                <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdvector-and-list-constructors/">
                                                 16.2 -- Introduction to std::vector and list constructors
                                                </a>
                                                . Because of such quirks, some experienced developers now advocate for using a mix of copy, direct, and list initialization, depending on the circumstance. Once you are familiar enough with the language to understand the nuances of each initialization type and the reasoning behind such recommendations, you can evaluate on your own whether you find these arguments persuasive.
                                               </p>
                                              </p>
                                             </p>
                                            </div>
                                            <p class="cpp-section cpp-topline" style="clear:both">
                                             Value-initialization and zero-initialization
                                             <p>
                                              When a variable is initialized using empty braces,
                                              <strong>
                                               value initialization
                                              </strong>
                                              takes place. In most cases,
                                              <strong>
                                               value initialization
                                              </strong>
                                              will initialize the variable to zero (or empty, if that’s more appropriate for a given type). In such cases where zeroing occurs, this is called
                                              <strong>
                                               zero-initialization
                                              </strong>
                                              .
                                              <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int width {}; // value-initialization / zero-initialization to value 0</code></pre>
                                              <div class="cpp-note cpp-lightbluebackground">
                                               <p class="cpp-note-title cpp-bottomline">
                                                Q: When should I initialize with { 0 } vs {}?
                                                <p>
                                                 Use direct-list-initialization when you’re actually using the initial value:
                                                 <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int x { 0 };    // direct-list-initialization with initial value 0
std::cout &lt;&lt; x; // we're using that 0 value here</code></pre>
                                                 <p>
                                                  Use value-initialization when the object’s value is temporary and will be replaced:
                                                  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int x {};      // value initialization
std::cin &gt;&gt; x; // we're immediately replacing that value so an explicit 0 would be meaningless</code></pre>
                                                 </p>
                                                </p>
                                               </p>
                                              </div>
                                              <p class="cpp-section cpp-topline" style="clear:both">
                                               Initialize your variables
                                               <p>
                                                Initialize your variables upon creation. You may eventually find cases where you want to ignore this advice for a specific reason (e.g. a performance critical section of code that uses a lot of variables), and that’s okay, as long as the choice is made deliberately.
                                                <div class="cpp-note cpp-lightgraybackground">
                                                 <p class="cpp-note-title cpp-bottomline">
                                                  Related content
                                                  <p>
                                                   For more discussion on this topic, Bjarne Stroustrup (creator of C++) and Herb Sutter (C++ expert) make this recommendation themselves
                                                   <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es20-always-initialize-an-object">
                                                    here
                                                   </a>
                                                   .
                                                  </p>
                                                 </p>
                                                </div>
                                                <p>
                                                 We explore what happens if you try to use a variable that doesn’t have a well-defined value in lesson
                                                 <a href="https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/">
                                                  1.6 -- Uninitialized variables and undefined behavior
                                                 </a>
                                                 .
                                                 <div class="cpp-note cpp-lightgreenbackground">
                                                  <p class="cpp-note-title cpp-bottomline">
                                                   Best practice
                                                   <p>
                                                    Initialize your variables upon creation.
                                                   </p>
                                                  </p>
                                                 </div>
                                                 <p class="cpp-section cpp-topline" style="clear:both">
                                                  Instantiation
                                                  <p>
                                                   The term
                                                   <strong>
                                                    instantiation
                                                   </strong>
                                                   is a fancy word that means a variable has been created (allocated) and initialized (this includes default initialization). An instantiated object is sometimes called an
                                                   <strong>
                                                    instance
                                                   </strong>
                                                   . Most often, this term is applied to class type objects, but it is occasionally applied to objects of other types as well.
                                                   <p class="cpp-section cpp-topline" style="clear:both">
                                                    Initializing multiple variables
                                                    <p>
                                                     In the last section, we noted that it is possible to define multiple variables
                                                     <em>
                                                      of the same type
                                                     </em>
                                                     in a single statement by separating the names with a comma:
                                                     <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int a, b; // create variables a and b, but do not initialize them</code></pre>
                                                     <p>
                                                      We also noted that best practice is to avoid this syntax altogether. However, since you may encounter other code that uses this style, it’s still useful to talk a little bit more about it, if for no other reason than to reinforce some of the reasons you should be avoiding it.
                                                      <p>
                                                       You can initialize multiple variables defined on the same line:
                                                       <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int a = 5, b = 6;          // copy-initialization
int c ( 7 ), d ( 8 );      // direct-initialization
int e { 9 }, f { 10 };     // direct-list-initialization
int i {}, j {};            // value-initialization</code></pre>
                                                       <p>
                                                        Unfortunately, there’s a common pitfall here that can occur when the programmer mistakenly tries to initialize both variables by using one initialization statement:
                                                        <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int a, b = 5;     // wrong: a is not initialized to 5!
int a = 5, b = 5; // correct: a and b are initialized to 5</code></pre>
                                                        <p>
                                                         In the top statement, variable
                                                         <code>
                                                          a
                                                         </code>
                                                         will be left uninitialized, and the compiler may or may not complain. If it doesn’t, this is a great way to have your program intermittently crash or produce sporadic results. We’ll talk more about what happens if you use uninitialized variables shortly.
                                                         <p>
                                                          The best way to remember that this is wrong is to note that each variable can only be initialized by its own initializer:
                                                          <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int a = 4, b = 5; // correct: a and b both have initializers
int a, b = 5;     // wrong: a doesn't have its own initializer</code></pre>
                                                          <p class="cpp-section cpp-topline" style="clear:both">
                                                           Unused initialized variables warnings
                                                           <p>
                                                            Modern compilers will typically generate warnings if a variable is initialized but not used (since this is rarely desirable). And if “treat warnings as errors” is enabled, these warnings will be promoted to errors and cause the compilation to fail.
                                                            <p>
                                                             Consider the following innocent looking program:
                                                             <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int main()
{
    int x { 5 }; // variable x defined

    // but not used anywhere

    return 0;
}</code></pre>
                                                             <p>
                                                              When compiling this with GCC and “treat warnings as errors” on, the following error is generated:
                                                              <pre>prog.cc: In function 'int main()':
prog.cc:3:9: error: unused variable 'x' [-Werror=unused-variable]
</pre>
                                                              <p>
                                                               and the program fails to compile.
                                                               <p>
                                                                There are a few easy ways to fix this.
                                                                <ol start="1">
                                                                 <li>
                                                                  If the variable really is unused and you don’t need it, then the easiest option is to remove the definition of
                                                                  <code>
                                                                   x
                                                                  </code>
                                                                  (or comment it out). After all, if it’s not used, then removing it won’t affect anything.
                                                                  <li>
                                                                   Another option is to simply use the variable somewhere:
                                                                  </li>
                                                                 </li>
                                                                </ol>
                                                                <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    int x { 5 };

    std::cout &lt;&lt; x; // variable now used somewhere

    return 0;
}</code></pre>
                                                                <p>
                                                                 But this requires some effort to write code that uses it, and has the downside of potentially changing your program’s behavior.
                                                                 <p class="cpp-section cpp-topline" style="clear:both">
                                                                  The
                                                                  <code>
                                                                   [[maybe_unused]]
                                                                  </code>
                                                                  attribute
                                                                  <p>
                                                                   In some cases, neither of the above options are desirable. Consider the case where we have a set of math/physics values that we use in many different programs:
                                                                   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    // Here's some math/physics values that we copy-pasted from elsewhere
    double pi { 3.14159 };
    double gravity { 9.8 };
    double phi { 1.61803 };

    std::cout &lt;&lt; pi &lt;&lt; '\n';  // pi is used
    std::cout &lt;&lt; phi &lt;&lt; '\n'; // phi is used

    // The compiler will likely complain about gravity being defined but unused

    return 0;
}</code></pre>
                                                                   <p>
                                                                    If we use these values a lot, we probably have these saved somewhere and copy/paste/import them all together.
                                                                    <p>
                                                                     However, in any program where we don’t use
                                                                     <em>
                                                                      all
                                                                     </em>
                                                                     of these values, the compiler will likely complain about each variable that isn’t actually used. In the above example, we could easily just remove the definition of
                                                                     <code>
                                                                      gravity
                                                                     </code>
                                                                     . But what if there were 20 or 30 variables instead of 3? And what if we use them in multiple places? Going through the list of variables to remove/comment out the unused ones takes time and energy. And later if we need one that we’ve previously removed, we’ll have to spend more time and energy to go back and re-add/uncomment it.
                                                                     <p>
                                                                      To address such cases, C++17 introduced the
                                                                      <code>
                                                                       [[maybe_unused]]
                                                                      </code>
                                                                      attribute, which allows us to tell the compiler that we’re okay with a variable being unused. The compiler will not generate unused variable warnings for such variables.
                                                                      <p>
                                                                       The following program should generate no warnings/errors:
                                                                       <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    [[maybe_unused]] double pi { 3.14159 };  // Don't complain if pi is unused
    [[maybe_unused]] double gravity { 9.8 }; // Don't complain if gravity is unused
    [[maybe_unused]] double phi { 1.61803 }; // Don't complain if phi is unused

    std::cout &lt;&lt; pi &lt;&lt; '\n';
    std::cout &lt;&lt; phi &lt;&lt; '\n';

    // The compiler will no longer warn about gravity not being used

    return 0;
}</code></pre>
                                                                       <p>
                                                                        Additionally, the compiler will likely optimize these variables out of the program, so they have no performance impact.
                                                                        <p>
                                                                         The
                                                                         <code>
                                                                          [[maybe_unused]]
                                                                         </code>
                                                                         attribute should only be applied selectively to variables that have a specific and legitimate reason for being unused (e.g. because you need a list of named values, but which specific values are actually used in a given program may vary). Otherwise, unused variables should be removed from the program.
                                                                         <div class="cpp-note cpp-lightgraybackground">
                                                                          <p class="cpp-note-title cpp-bottomline">
                                                                           Author’s note
                                                                           <p>
                                                                            In future lessons, we’ll often define variables we don’t use again, in order to demonstrate the syntax for certain concepts. Making use of
                                                                            <code>
                                                                             [[maybe_unused]]
                                                                            </code>
                                                                            allows us to do so without compilation warnings/errors.
                                                                           </p>
                                                                          </p>
                                                                         </div>
                                                                         <p class="cpp-section cpp-topline" style="clear:both">
                                                                          Quiz time
                                                                          <p class="cpp-quiz-question" style="clear:both">
                                                                           Question #1
                                                                           <p>
                                                                            What is the difference between initialization and assignment?
                                                                            <p>
                                                                             <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">
                                                                              Show Solution
                                                                             </a>
                                                                             <div class="wpsolution" id="cpp_solution_id_0" style="display:none">
                                                                              <p>
                                                                               Initialization gives a variable an initial value at the point when it is created. Assignment gives a variable a value at some point after the variable is created.
                                                                              </p>
                                                                             </div>
                                                                             <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                              Question #2
                                                                              <p>
                                                                               What form of initialization should you prefer when you want to initialize a variable with a specific value?
                                                                               <p>
                                                                                <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">
                                                                                 Show Solution
                                                                                </a>
                                                                                <div class="wpsolution" id="cpp_solution_id_1" style="display:none">
                                                                                 <p>
                                                                                  Direct-list-initialization (aka. direct brace initialization).
                                                                                 </p>
                                                                                </div>
                                                                                <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                                 Question #3
                                                                                 <p>
                                                                                  What are default-initialization and value-initialization? What is the behavior of each? Which should you prefer?
                                                                                  <p>
                                                                                   <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">
                                                                                    Show Solution
                                                                                   </a>
                                                                                   <div class="wpsolution" id="cpp_solution_id_2" style="display:none">
                                                                                    <p>
                                                                                     Default-initialization is when a variable initialization has no initializer (e.g.
                                                                                     <code>
                                                                                      int x;
                                                                                     </code>
                                                                                     ). In most cases, the variable is left with an indeterminate value.
                                                                                     <p>
                                                                                      Value-initialization is when a variable initialization has an empty brace initializer (e.g.
                                                                                      <code>
                                                                                       int x{};
                                                                                      </code>
                                                                                      ). In most cases this will perform zero-initialization.
                                                                                      <p>
                                                                                       You should prefer value-initialization, as it initializes the variable to a consistent value.
                                                                                      </p>
                                                                                     </p>
                                                                                    </p>
                                                                                   </div>
                                                                                  </p>
                                                                                 </p>
                                                                                </p>
                                                                               </p>
                                                                              </p>
                                                                             </p>
                                                                            </p>
                                                                           </p>
                                                                          </p>
                                                                         </p>
                                                                        </p>
                                                                       </p>
                                                                      </p>
                                                                     </p>
                                                                    </p>
                                                                   </p>
                                                                  </p>
                                                                 </p>
                                                                </p>
                                                               </p>
                                                              </p>
                                                             </p>
                                                            </p>
                                                           </p>
                                                          </p>
                                                         </p>
                                                        </p>
                                                       </p>
                                                      </p>
                                                     </p>
                                                    </p>
                                                   </p>
                                                  </p>
                                                 </p>
                                                </p>
                                               </p>
                                              </p>
                                             </p>
                                            </p>
                                           </p>
                                          </p>
                                         </p>
                                        </p>
                                       </p>
                                      </p>
                                     </p>
                                    </p>
                                   </p>
                                  </p>
                                 </p>
                                </p>
                               </p>
                              </p>
                             </p>
                            </p>
                           </p>
                          </p>
                         </p>
                        </p>
                       </p>
                      </p>
                     </p>
                    </p>
                   </p>
                  </p>
                 </p>
                </p>
               </p>
              </p>
             </p>
            </p>
           </p>
          </p>
         </p>
        </p>
       </p>
      </p>
     </p>
    </p>
   </p>
  </p>
 </div>
</div>
