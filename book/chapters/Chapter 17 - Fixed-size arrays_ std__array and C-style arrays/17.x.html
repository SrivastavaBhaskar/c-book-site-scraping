<div class="article-inner">
 <header>
  <div class="entry-meta beforetitle-meta">
  </div>
  <h1 class="entry-title singular-title" itemprop="headline">
   17.x — Chapter 17 summary and quiz
  </h1>
  <div class="entry-meta aftertitle-meta">
  </div>
 </header>
 <div class="entry-content" itemprop="articleBody">
  <p class="cpp-section">
   Chapter Review
   <p>
    <strong>
     Fixed-size arrays
    </strong>
    (or
    <strong>
     fixed-length arrays
    </strong>
    ) require that the length of the array be known at the point of instantiation, and that length cannot be changed afterward. C-style arrays and
    <code>
     std::array
    </code>
    are both fixed-size arrays. Dynamic arrays can be resized at runtime.
    <code>
     std::vector
    </code>
    is a dynamic array.
    <p>
     The length of a
     <code>
      std::array
     </code>
     must be a constant expression. Most often, the value provided for the length will be an integer literal, constexpr variable, or an unscoped enumerator.
     <p>
      <code>
       std::array
      </code>
      is an aggregate. This means it has no constructors, and instead is initialized using aggregate initialization.
      <p>
       Define your
       <code>
        std::array
       </code>
       as constexpr whenever possible. If your
       <code>
        std::array
       </code>
       is not constexpr, consider using a
       <code>
        std::vector
       </code>
       instead.
       <p>
        Use class template argument deduction (CTAD) to have the compiler deduce the type and length of a std::array from its initializers.
        <p>
         <code>
          std::array
         </code>
         is implemented as a template struct whose declaration looks like this:
         <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">template&lt;typename T, std::size_t N&gt; // N is a non-type template parameter
struct array;</code></pre>
         <p>
          The non-type template parameter representing the array length (
          <code>
           N
          </code>
          ) has type
          <code>
           std::size_t
          </code>
          .
          <p>
           To get the length of a
           <code>
            std::array
           </code>
           :
           <ul>
            <li>
             We can ask a
             <code>
              std::array
             </code>
             object for its length using the
             <code>
              size()
             </code>
             member function (which returns the length as unsigned
             <code>
              size_type
             </code>
             ).
             <li>
              In C++17, we can use the
              <code>
               std::size()
              </code>
              non-member function (which for
              <code>
               std::array
              </code>
              just calls the
              <code>
               size()
              </code>
              member function, thus returning the length as unsigned
              <code>
               size_type
              </code>
              ).
              <li>
               In C++20, we can use the
               <code>
                std::ssize()
               </code>
               non-member function, which returns the length as a large
               <em>
                signed
               </em>
               integral type (usually
               <code>
                std::ptrdiff_t
               </code>
               ).
              </li>
             </li>
            </li>
           </ul>
           <p>
            All three of these functions will return the length as a constexpr value, except when called on a
            <code>
             std::array
            </code>
            passed by reference. This defect has been addressed in C++23 by
            <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2280r4.html">
             P2280
            </a>
            .
            <p>
             To index a
             <code>
              std::array
             </code>
             :
             <ul>
              <li>
               Use the subscript operator (
               <code>
                operator[]
               </code>
               ). No bounds checking is done in this case, and passing in an invalid index will result in undefined behavior.
               <li>
                Use the
                <code>
                 at()
                </code>
                member function that does subscripting with runtime bounds checking. We recommend avoiding this function since we typically want to do bounds checking before indexing, or we want compile-time bounds checking.
                <li>
                 Use the
                 <code>
                  std::get()
                 </code>
                 function template, which takes the index as a non-type template argument, and does compile-time bounds checking.
                </li>
               </li>
              </li>
             </ul>
             <p>
              You can pass
              <code>
               std::array
              </code>
              with different element types and lengths to a function using a function template with the template parameter declaration
              <code>
               template &lt;typename T, std::size_t N&gt;
              </code>
              . Or in C++20, use
              <code>
               template &lt;typename T, auto N&gt;
              </code>
              .
              <p>
               Returning a
               <code>
                std::array
               </code>
               by value will make a copy of the array and all elements, but this may be okay if the array is small and the elements aren’t expensive to copy. Using an out parameter instead may be a better choice in some contexts.
               <p>
                When initializing a
                <code>
                 std::array
                </code>
                with a struct, class, or array and not providing the element type with each initializer, you’ll need an extra pair of braces so that the compiler will properly interpret what to initialize. This is an artifact of aggregate initialization, and other standard library container types (that use list constructors) do not require the double braces in these cases.
                <p>
                 Aggregates in C++ support a concept called
                 <strong>
                  brace elision
                 </strong>
                 , which lays out some rules for when multiple braces may be omitted. Generally, you can omit braces when initializing a
                 <code>
                  std::array
                 </code>
                 with scalar (single) values, or when initializing with class types or arrays where the type is explicitly named with each element.
                 <p>
                  You can not have an array of references, but you can have an array of
                  <code>
                   std::reference_wrapper
                  </code>
                  , which behaves like a modifiable lvalue reference.
                  <p>
                   There are a few things worth noting about
                   <code>
                    std::reference_wrapper
                   </code>
                   :
                   <ul>
                    <li>
                     <code>
                      Operator=
                     </code>
                     will reseat a
                     <code>
                      std::reference_wrapper
                     </code>
                     (change which object is being referenced).
                     <li>
                      <code>
                       std::reference_wrapper&lt;T&gt;
                      </code>
                      will implicitly convert to
                      <code>
                       T&amp;
                      </code>
                      .
                      <li>
                       The
                       <code>
                        get()
                       </code>
                       member function can be used to get a
                       <code>
                        T&amp;
                       </code>
                       . This is useful when we want to update the value of the object being referenced.
                      </li>
                     </li>
                    </li>
                   </ul>
                   <p>
                    The
                    <code>
                     std::ref()
                    </code>
                    and
                    <code>
                     std::cref()
                    </code>
                    functions were provided as shortcuts to create
                    <code>
                     std::reference_wrapper
                    </code>
                    and
                    <code>
                     const std::reference_wrapper
                    </code>
                    wrapped objects.
                    <p>
                     Use
                     <code>
                      static_assert
                     </code>
                     whenever possible to ensure a
                     <code>
                      constexpr std::array
                     </code>
                     using CTAD has the correct number of initializers.
                     <p>
                      C-style arrays were inherited from the C language, and are built-in to the core language of C++. Because they are part of the core language, C-style arrays have their own special declaration syntax. In an C-style array declaration, we use square brackets ([]) to tell the compiler that a declared object is a C-style array. Inside the square brackets, we can optionally provide the length of the array, which is an integral value of type std::size_t that tells the compiler how many elements are in the array. The length of a C-style array must be a constant expression.
                      <p>
                       C-style arrays are aggregates, which means they can be initialized using aggregate initialization. When using an initializer list to initialize all elements of a C-style array, it’s preferable to omit the length and let the compiler calculate the length of the array.
                       <p>
                        C-style arrays can be indexed via
                        <code>
                         operator[]
                        </code>
                        . The index of a C-style array can be either a signed or an unsigned integer, or an unscoped enumeration. This means that C-style arrays are not subject to all of the sign conversion indexing issues that the standard library container classes have!
                        <p>
                         C-style arrays can be const or constexpr.
                         <p>
                          To get the length of a C-style array:
                          <ul>
                           <li>
                            In C++17, we can use the
                            <code>
                             std::size()
                            </code>
                            non-member function, which returns the length as unsigned
                            <code>
                             std::size_t
                            </code>
                            .
                            <li>
                             In C++20, we can use the
                             <code>
                              std::ssize()
                             </code>
                             non-member function, which returns the length as a large
                             <em>
                              signed
                             </em>
                             integral type (usually
                             <code>
                              std::ptrdiff_t
                             </code>
                             ).
                            </li>
                           </li>
                          </ul>
                          <p>
                           In most cases, when a C-style array is used in an expression, the array will be implicitly converted into a pointer to the element type, initialized with the address of the first element (with index 0). Colloquially, this is called
                           <strong>
                            array decay
                           </strong>
                           (or just decay for short).
                           <p>
                            <strong>
                             Pointer arithmetic
                            </strong>
                            is a feature the allows us to apply certain integer arithmetic operators (addition, subtraction, increment, or decrement) to a pointer to produce a new memory address. Given some pointer
                            <code>
                             ptr
                            </code>
                            ,
                            <code>
                             ptr + 1
                            </code>
                            returns the address of the next
                            <em>
                             object
                            </em>
                            in memory (based on the type being pointed to).
                            <p>
                             Use subscripting when indexing from the start of the array (element 0), so the array indices line up with the element.
                             <br/>
                             Use pointer arithmetic when doing relative positioning from a given element.
                             <p>
                              C-style strings are just C-style arrays whose element type is
                              <code>
                               char
                              </code>
                              or
                              <code>
                               const char
                              </code>
                              . As such, C-style strings will decay.
                              <p>
                               The
                               <strong>
                                dimension
                               </strong>
                               of an array is the number of indices needed to select an element.
                               <p>
                                An array containing only a single dimension is called a
                                <strong>
                                 single-dimensional array
                                </strong>
                                or a
                                <strong>
                                 one-dimensional array
                                </strong>
                                (sometimes abbreviated as a
                                <strong>
                                 1d array
                                </strong>
                                ). An array of arrays is called a
                                <strong>
                                 two-dimensional array
                                </strong>
                                (sometimes abbreviated as a
                                <strong>
                                 2d array
                                </strong>
                                ) because it has two subscripts. Arrays with more than one dimension are called
                                <strong>
                                 multidimensional arrays
                                </strong>
                                .
                                <strong>
                                 Flattening
                                </strong>
                                an array is a process of reducing the dimensionality of an array (often down to a single dimension).
                                <p>
                                 In C++23,
                                 <code>
                                  std::mdspan
                                 </code>
                                 is a view that provides a multidimensional array interface for a contiguous sequence of elements.
                                 <p class="cpp-section cpp-topline" style="clear:both">
                                  Quiz time
                                  <p class="cpp-quiz-question" style="clear:both">
                                   Question #1
                                   <p>
                                    What’s wrong with each of these snippets, and how would you fix it?
                                    <p>
                                     a)
                                     <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;

int main()
{
    std::array arr { 0, 1, 2, 3 };

    for (std::size_t count{ 0 }; count &lt;= std::size(arr); ++count)
    {
        std::cout &lt;&lt; arr[count] &lt;&lt; ' ';
    }

    std::cout &lt;&lt; '\n';

    return 0;
}</code></pre>
                                     <p>
                                      <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">
                                       Show Solution
                                      </a>
                                      <div class="wpsolution" id="cpp_solution_id_0" style="display:none">
                                       <p>
                                        The for-loop has an off-by-one error, and tries to access the array element with index 4, which does not exist.
                                        <p>
                                         Solution: the conditional in the for loop should use &lt; instead of &lt;=.
                                        </p>
                                       </p>
                                      </div>
                                      <p>
                                       b)
                                       <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

void printArray(int array[])
{
    for (int element : array)
    {
        std::cout &lt;&lt; element &lt;&lt; ' ';
    }
}

int main()
{
    int array[] { 9, 7, 5, 3, 1 };

    printArray(array);

    std::cout &lt;&lt; '\n';

    return 0;
}</code></pre>
                                       <p>
                                        <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">
                                         Show Solution
                                        </a>
                                        <div class="wpsolution" id="cpp_solution_id_1" style="display:none">
                                         <p>
                                          <code>
                                           array
                                          </code>
                                          decays to a pointer when it is passed to
                                          <code>
                                           printArray()
                                          </code>
                                          . Range-based for-loops can’t work with a pointer to an array because the size of the array isn’t known.
                                          <p>
                                           Solution: use
                                           <code>
                                            std::array
                                           </code>
                                           instead, which doesn’t decay.
                                          </p>
                                         </p>
                                        </div>
                                        <p>
                                         c)
                                         <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; "Enter the number of test scores: ";
    std::size_t length{};
    std::cin &gt;&gt; length;

    std::array&lt;int, length&gt; scores;

    for (std::size_t i { 0 } ; i &lt; length; ++i)
    {
        std::cout &lt;&lt; "Enter score " &lt;&lt; i &lt;&lt; ": ";
        std::cin &gt;&gt; scores[i];
    }
    return 0;
}</code></pre>
                                         <p>
                                          <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">
                                           Show Solution
                                          </a>
                                          <div class="wpsolution" id="cpp_solution_id_2" style="display:none">
                                           <p>
                                            <code>
                                             length
                                            </code>
                                            is not a constant expression, and cannot be used to define the length of
                                            <code>
                                             std::array
                                            </code>
                                            .
                                            <p>
                                             Solution: use a
                                             <code>
                                              std::vector
                                             </code>
                                             instead.
                                            </p>
                                           </p>
                                          </div>
                                          <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                           Question #2
                                           <p>
                                            In this quiz, we’re going to implement Roscoe’s potion emporium, the finest potion shop in the land! This is going to be a bigger challenge.
                                            <p>
                                             Implement a program that outputs the following:
                                             <pre>Welcome to Roscoe's potion emporium!
Enter your name: Alex
Hello, Alex, you have 85 gold.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
Enter the number of the potion you'd like to buy, or 'q' to quit: a
That is an invalid input.  Try again: 3
You purchased a potion of invisibility.  You have 35 gold left.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
Enter the number of the potion you'd like to buy, or 'q' to quit: 4
That is an invalid input.  Try again: 2
You purchased a potion of speed.  You have 23 gold left.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
Enter the number of the potion you'd like to buy, or 'q' to quit: 2
You purchased a potion of speed.  You have 11 gold left.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
Enter the number of the potion you'd like to buy, or 'q' to quit: 4
You can not afford that.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
Enter the number of the potion you'd like to buy, or 'q' to quit: q

Your inventory contains: 
2x potion of speed
1x potion of invisibility
You escaped with 11 gold remaining.

Thanks for shopping at Roscoe's potion emporium!
</pre>
                                             <p>
                                              The player starts with a randomized amount of gold, between 80 and 120.
                                              <p>
                                               Sound fun? Let’s do it! Because this will be hard to implement all at once, we’ll develop this in steps.
                                               <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                &gt; Step #1
                                                <p>
                                                 Create a
                                                 <code>
                                                  Potion
                                                 </code>
                                                 namespace containing an enum named
                                                 <code>
                                                  Type
                                                 </code>
                                                 containing the potion types. Create two
                                                 <code>
                                                  std::array
                                                 </code>
                                                 : an
                                                 <code>
                                                  int
                                                 </code>
                                                 array to hold the potion costs, and a
                                                 <code>
                                                  std::string_view
                                                 </code>
                                                 array to hold the potion names.
                                                 <p>
                                                  Also write a function named
                                                  <code>
                                                   shop()
                                                  </code>
                                                  that enumerates through the list of
                                                  <code>
                                                   Potions
                                                  </code>
                                                  and prints their numbers, names, and cost.
                                                  <p>
                                                   The program should output the following:
                                                   <pre>Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
</pre>
                                                   <p>
                                                    <a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">
                                                     Show Hint
                                                    </a>
                                                    <div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">
                                                     Hint: We show a method for iterating through an enumeration using a range-based for-loop in lesson
                                                     <a href="https://www.learncpp.com/cpp-tutorial/stdarray-and-enumerations/">
                                                      17.6 -- std::array and enumerations
                                                     </a>
                                                     .
                                                    </div>
                                                    <p>
                                                     <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">
                                                      Show Solution
                                                     </a>
                                                     <div class="wpsolution" id="cpp_solution_id_3" style="display:none">
                                                      <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;

namespace Potion
{
    enum Type
    {
    healing,
    mana,
    speed,
    invisibility,
    max_potions
    };

    constexpr std::array types { healing, mana, speed, invisibility }; // An array of our enumerators

    // We could put these in a struct, but since we only have two attributes we'll keep them separate for now
    // We will explicitly define the element type so we don't have to use the sv suffix
    constexpr std::array&lt;std::string_view, max_potions&gt; name { "healing", "mana", "speed", "invisibility" };
    constexpr std::array cost { 20, 30, 12, 50 };

    static_assert(std::size(types) == max_potions);  // ensure 'all' contains the correct number of enumerators
    static_assert(std::size(cost) == max_potions);
    static_assert(std::size(name) == max_potions);
}

void shop()
{
    std::cout &lt;&lt; "Here is our selection for today:\n";

    for (auto p: Potion::types)
        std::cout &lt;&lt; p &lt;&lt; ") " &lt;&lt; Potion::name[p] &lt;&lt; " costs " &lt;&lt; Potion::cost[p] &lt;&lt; '\n';
}

int main()
{
    shop();

    return 0;
}</code></pre>
                                                     </div>
                                                     <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                      &gt; Step #2
                                                      <p>
                                                       Create a
                                                       <code>
                                                        Player
                                                       </code>
                                                       class to store the player’s name, potion inventory, and gold. Add the introductory and goodbye text for Roscoe’s emporium. Get the player’s name and randomize their gold.
                                                       <p>
                                                        Use the “Random.h” file in lesson
                                                        <a href="https://www.learncpp.com/cpp-tutorial/global-random-numbers-random-h/#RandomH">
                                                         8.15 -- Global random numbers (Random.h)
                                                        </a>
                                                        to make randomization easy.
                                                        <p>
                                                         The program should output the following:
                                                         <pre>Welcome to Roscoe's potion emporium!
Enter your name: Alex
Hello, Alex, you have 84 gold.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50

Thanks for shopping at Roscoe's potion emporium!
</pre>
                                                         <p>
                                                          <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">
                                                           Show Solution
                                                          </a>
                                                          <div class="wpsolution" id="cpp_solution_id_4" style="display:none">
                                                           <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
#include "Random.h"

namespace Potion
{
    enum Type
    {
        healing,
        mana,
        speed,
        invisibility,
        max_potions
    };

    constexpr std::array types { healing, mana, speed, invisibility }; // An array of our enumerators

    // We could put these in a struct, but since we only have two attributes we'll keep them separate for now
    // We will explicitly define the element type so we don't have to use the sv suffix
    constexpr std::array&lt;std::string_view, max_potions&gt; name { "healing", "mana", "speed", "invisibility" };
    constexpr std::array cost { 20, 30, 12, 50 };

    static_assert(std::size(types) == max_potions);  // ensure 'all' contains the correct number of enumerators
    static_assert(std::size(cost) == max_potions);
    static_assert(std::size(name) == max_potions);
}

class Player
{
private:
    static constexpr int s_minStartingGold { 80 };
    static constexpr int s_maxStartingGold { 120 };

    std::string m_name {};
    int m_gold {};
    std::array&lt;int, Potion::max_potions&gt; m_inventory { };

public:
    explicit Player(std::string_view name) :
        m_name { name },
        m_gold { Random::get(s_minStartingGold, s_maxStartingGold) }
    { 
    }

    int gold() const { return m_gold; }
    int inventory(Potion::Type p) const { return m_inventory[p]; }
};

void shop()
{
    std::cout &lt;&lt; "Here is our selection for today:\n";

    for (auto p: Potion::types)
        std::cout &lt;&lt; p &lt;&lt; ") " &lt;&lt; Potion::name[p] &lt;&lt; " costs " &lt;&lt; Potion::cost[p] &lt;&lt; '\n';
}

int main()
{
    std::cout &lt;&lt; "Welcome to Roscoe's potion emporium!\n";
    std::cout &lt;&lt; "Enter your name: ";

    std::string name{};
    std::getline(std::cin &gt;&gt; std::ws, name); // read a full line of text into name

    Player player { name };

    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; ", you have " &lt;&lt; player.gold() &lt;&lt; " gold.\n\n";

    shop();

    std::cout &lt;&lt; "\nThanks for shopping at Roscoe's potion emporium!\n";

    return 0;
}</code></pre>
                                                          </div>
                                                          <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                           &gt; Step #3
                                                           <p>
                                                            Add the ability to purchase potions, handling invalid input (treat any extraneous input as a failure). Print the player’s inventory after they leave. The program should be complete after this step.
                                                            <p>
                                                             Make sure you test for the following cases:
                                                             <ul>
                                                              <li>
                                                               User enters an invalid potion number (e.g. ‘d’)
                                                               <li>
                                                                User enters a valid potion number but with extraneous input (e.g.
                                                                <code>
                                                                 2d
                                                                </code>
                                                                ,
                                                                <code>
                                                                 25
                                                                </code>
                                                                )
                                                               </li>
                                                              </li>
                                                             </ul>
                                                             <p>
                                                              We cover invalid input handling in lesson
                                                              <a href="https://www.learncpp.com/cpp-tutorial/stdcin-and-handling-invalid-input/">
                                                               9.5 -- std::cin and handling invalid input
                                                              </a>
                                                              .
                                                              <p>
                                                               <a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_1'),this,'Show Hint','')">
                                                                Show Hint
                                                               </a>
                                                               <div class="wphint" id="cpp_hint_id_1" style="display:none;margin-bottom:1em">
                                                                Hint: The user can enter either a number or ‘q’, so extract the user’s input to type
                                                                <code>
                                                                 char
                                                                </code>
                                                                .
                                                                <p>
                                                                 <p>
                                                                  To convert an ASCII number character to an int (e.g.
                                                                  <code>
                                                                   '5'
                                                                  </code>
                                                                  to
                                                                  <code>
                                                                   5
                                                                  </code>
                                                                  ), you can use the following:
                                                                  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int charNumToInt(char c)
{
    return c - '0';
}</code></pre>
                                                                 </p>
                                                                </p>
                                                               </div>
                                                               <p>
                                                                <a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_2'),this,'Show Hint','')">
                                                                 Show Hint
                                                                </a>
                                                                <div class="wphint" id="cpp_hint_id_2" style="display:none;margin-bottom:1em">
                                                                 Hint: Write a function to handle user input. It should return the
                                                                 <code>
                                                                  Potion::Type
                                                                 </code>
                                                                 the user selected. If the user quit instead, the function can return
                                                                 <code>
                                                                  Potion::max_potions
                                                                 </code>
                                                                 . You will need to static_cast the user’s input to a
                                                                 <code>
                                                                  Potion::Type
                                                                 </code>
                                                                 .
                                                                </div>
                                                                <p>
                                                                 <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">
                                                                  Show Solution
                                                                 </a>
                                                                 <div class="wpsolution" id="cpp_solution_id_5" style="display:none">
                                                                  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt; // for std::numeric_limits
#include &lt;string_view&gt;
#include "Random.h"

namespace Potion
{
    enum Type
    {
        healing,
        mana,
        speed,
        invisibility,
        max_potions
    };

    constexpr std::array types { healing, mana, speed, invisibility }; // An array of our enumerators

    // We could put these in a struct, but since we only have two attributes we'll keep them separate for now
    // We will explicitly define the element type so we don't have to use the sv suffix
    constexpr std::array&lt;std::string_view, max_potions&gt; name { "healing", "mana", "speed", "invisibility" };
    constexpr std::array cost { 20, 30, 12, 50 };

    static_assert(std::size(types) == max_potions);  // ensure 'all' contains the correct number of enumerators
    static_assert(std::size(cost) == max_potions);
    static_assert(std::size(name) == max_potions);
}

class Player
{
private:
    static constexpr int s_minStartingGold { 80 };
    static constexpr int s_maxStartingGold { 120 };

    std::string m_name {};
    int m_gold {};
    std::array&lt;int, Potion::max_potions&gt; m_inventory { };

public:
    explicit Player(std::string_view name) :
        m_name { name },
        m_gold { Random::get(s_minStartingGold, s_maxStartingGold) }
    { 
    }

    // returns false if can't afford, true if purchased
    bool buy(Potion::Type type)
    {
        if (m_gold &lt; Potion::cost[type])
            return false;

        m_gold -= Potion::cost[type];
        ++m_inventory[type];
        return true;
    }

    int gold() const { return m_gold; }
    int inventory(Potion::Type p) const { return m_inventory[p]; }
};

void ignoreLine()
{
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
}

int charNumToInt(char c)
{
    return c - '0';
}

Potion::Type whichPotion()
{
    std::cout &lt;&lt; "Enter the number of the potion you'd like to buy, or 'q' to quit: ";
    char input{};
    while (true)
    {
        std::cin &gt;&gt; input;
        if (!std::cin)
        {
            std::cin.clear(); // put us back in 'normal' operation mode
            ignoreLine(); // and remove the bad input
            continue;
        }

        // If there is extraneous input, treat as failure case
        if (!std::cin.eof() &amp;&amp; std::cin.peek() != '\n')
        {
            std::cout &lt;&lt; "I didn't understand what you said.  Try again: ";
            ignoreLine(); // ignore any extraneous input
            continue;
        }

        if (input == 'q')
            return Potion::max_potions;

        // Convert the char to a number and see if it's a valid potion selection
        int val { charNumToInt(input) };
        if (val &gt;= 0 &amp;&amp; val &lt; Potion::max_potions)
            return static_cast&lt;Potion::Type&gt;(val);

        // It wasn't a valid potion selection
        std::cout &lt;&lt; "I didn't understand what you said.  Try again: ";
        ignoreLine();
    }
}

void shop(Player &amp;player)
{
    while (true)
    {
        std::cout &lt;&lt; "Here is our selection for today:\n";

        for (auto p: Potion::types)
            std::cout &lt;&lt; p &lt;&lt; ") " &lt;&lt; Potion::name[p] &lt;&lt; " costs " &lt;&lt; Potion::cost[p] &lt;&lt; '\n';
        
        Potion::Type which { whichPotion() };
        if (which == Potion::max_potions)
            return;

        bool success { player.buy(which) };
        if (!success)
            std::cout &lt;&lt; "You can not afford that.\n\n";
        else
            std::cout &lt;&lt; "You purchased a potion of " &lt;&lt; Potion::name[which] &lt;&lt; ".  You have " &lt;&lt; player.gold() &lt;&lt; " gold left.\n\n";
    }
}

void printInventory(Player&amp; player)
{
    std::cout &lt;&lt; "Your inventory contains: \n";
    
    for (auto p: Potion::types)
    {
        if (player.inventory(p) &gt; 0)
            std::cout &lt;&lt; player.inventory(p) &lt;&lt; "x potion of " &lt;&lt; Potion::name[p] &lt;&lt; '\n';
    }

    std::cout &lt;&lt; "You escaped with " &lt;&lt; player.gold() &lt;&lt; " gold remaining.\n";
}

int main()
{
    std::cout &lt;&lt; "Welcome to Roscoe's potion emporium!\n";
    std::cout &lt;&lt; "Enter your name: ";

    std::string name{};
    std::cin &gt;&gt; name;

    Player player { name };

    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; ", you have " &lt;&lt; player.gold() &lt;&lt; " gold.\n\n";

    shop(player);

    std::cout &lt;&lt; '\n';

    printInventory(player);

    std::cout &lt;&lt; "\nThanks for shopping at Roscoe's potion emporium!\n";

    return 0;
}</code></pre>
                                                                 </div>
                                                                 <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                  Question #3
                                                                  <p>
                                                                   Let’s say we want to write a card game that uses a standard deck of cards. In order to do that, we’re going to need some way to represent those cards, and decks of cards. Let’s build that functionality.
                                                                   <p>
                                                                    We’ll use it in the next quiz question to actually implement a game.
                                                                    <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                     &gt; Step #1
                                                                     <p>
                                                                      A deck of cards has 52 unique cards (13 card ranks of 4 suits). Create enumerations for the card ranks (ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king) and suits (clubs, diamonds, hearts, spades).
                                                                      <p>
                                                                       <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">
                                                                        Show Solution
                                                                       </a>
                                                                       <div class="wpsolution" id="cpp_solution_id_6" style="display:none">
                                                                        <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">// Because identifiers can't start with a number, we'll use a "rank_" prefix for these
enum Rank
{
    rank_ace,
    rank_2,
    rank_3,
    rank_4,
    rank_5,
    rank_6,
    rank_7,
    rank_8,
    rank_9,
    rank_10,
    rank_jack,
    rank_queen,
    rank_king,

    max_ranks
};

// We'll also prefix these for consistency
enum Suit
{
    suit_club,
    suit_diamond,
    suit_heart,
    suit_spade,

    max_suits
};</code></pre>
                                                                       </div>
                                                                       <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                        &gt; Step #2
                                                                        <p>
                                                                         Each card will be represented by a struct named
                                                                         <code>
                                                                          Card
                                                                         </code>
                                                                         that contains a rank and a suit member. Create the struct and move the enums into it.
                                                                         <p>
                                                                          <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">
                                                                           Show Solution
                                                                          </a>
                                                                          <div class="wpsolution" id="cpp_solution_id_7" style="display:none">
                                                                           <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    Rank rank{};
    Suit suit{};
};</code></pre>
                                                                          </div>
                                                                          <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                           &gt; Step #3
                                                                           <p>
                                                                            Next, let’s add some useful functions to our Card struct. First, overload
                                                                            <code>
                                                                             operator&lt;&lt;
                                                                            </code>
                                                                            to print the card rank and suit as a 2-letter code (e.g. the jack of spades would print as JS). You can do that by completing the following function:
                                                                            <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">struct Card
{
    // Your other stuff here

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        out &lt;&lt; // print your card rank and suit here
        return out;
    }
};</code></pre>
                                                                            <p>
                                                                             Second, add a function that returns the value of the Card. Treat an ace as value 11. Finally, add a
                                                                             <code>
                                                                              std::array
                                                                             </code>
                                                                             of Rank and of Suit (named
                                                                             <code>
                                                                              allRanks
                                                                             </code>
                                                                             and
                                                                             <code>
                                                                              allSuits
                                                                             </code>
                                                                             respectively) so they can be iterated over. Because these are part of a struct (not a namespace), make them static so they are only instantiated once (not with each object).
                                                                             <p>
                                                                              The following should compile:
                                                                              <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int main()
{
    // Print one card
    Card card { Card::rank_5, Card::suit_heart };
    std::cout &lt;&lt; card &lt;&lt; '\n';

    // Print all cards
    for (auto suit : Card::allSuits)
        for (auto rank : Card::allRanks)
            std::cout &lt;&lt; Card { rank, suit } &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    return 0;
}</code></pre>
                                                                              <p>
                                                                               and produce the following output:
                                                                               <pre>5H
AC 2C 3C 4C 5C 6C 7C 8C 9C TC JC QC KC AD 2D 3D 4D 5D 6D 7D 8D 9D TD JD QD KD AH 2H 3H 4H 5H 6H 7H 8H 9H TH JH QH KH AS 2S 3S 4S 5S 6S 7S 8S 9S TS JS QS KS 
</pre>
                                                                               <p>
                                                                                <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">
                                                                                 Show Solution
                                                                                </a>
                                                                                <div class="wpsolution" id="cpp_solution_id_8" style="display:none">
                                                                                 <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    // These need to be static so they are only created once per program, not once per Card
    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };
        static constexpr std::array suits { 'C', 'D', 'H', 'S' };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

int main()
{
    // Print one card
    Card card { Card::rank_5, Card::suit_heart };
    std::cout &lt;&lt; card &lt;&lt; '\n';

    // Print all cards
    for (auto suit : Card::allSuits)
        for (auto rank : Card::allRanks)
            std::cout &lt;&lt; Card { rank, suit } &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    return 0;
}</code></pre>
                                                                                </div>
                                                                                <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                                 &gt; Step #4
                                                                                 <p>
                                                                                  Next, let’s create our deck of cards. Create a class named
                                                                                  <code>
                                                                                   Deck
                                                                                  </code>
                                                                                  that contains a
                                                                                  <code>
                                                                                   std::array
                                                                                  </code>
                                                                                  of Cards. You can assume a deck is 52 Cards.
                                                                                  <p>
                                                                                   The Deck should have three functions:
                                                                                   <p>
                                                                                    First, the default constructor should initialize the array of cards. You can use a ranged-for loop similar to the one in the main() function of the prior example to traverse through all the suits and ranks.
                                                                                    <p>
                                                                                     Second, add a
                                                                                     <code>
                                                                                      dealCard()
                                                                                     </code>
                                                                                     function that returns the next card in the Deck by value. Since
                                                                                     <code>
                                                                                      std::array
                                                                                     </code>
                                                                                     is a fixed-size array, think about how you will keep track of where the next card is. This function should assert out if it is called when the Deck has gone through all the cards.
                                                                                     <p>
                                                                                      Third, write a
                                                                                      <code>
                                                                                       shuffle()
                                                                                      </code>
                                                                                      member function that shuffles the deck. To make this easy, we will enlist the help of
                                                                                      <code>
                                                                                       std::shuffle
                                                                                      </code>
                                                                                      :
                                                                                      <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include "Random.h"  // for Random::mt

    // Put this line in your shuffle function to shuffle m_cards using the Random::mt Mersenne Twister
    // This will rearrange all the Cards in the deck randomly
    std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);</code></pre>
                                                                                      <p>
                                                                                       The
                                                                                       <code>
                                                                                        shuffle()
                                                                                       </code>
                                                                                       function should also reset however you are tracking where the next card is back to the start of the deck.
                                                                                       <p>
                                                                                        The following program should run:
                                                                                        <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int main()
{
    Deck deck{};
    std::cout &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; '\n';

    deck.shuffle();
    std::cout &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; '\n';

    return 0;
}</code></pre>
                                                                                        <p>
                                                                                         and produce the following output (the last 3 cards should be randomized):
                                                                                         <pre>AC 2C 3C
2H 7H 9C
</pre>
                                                                                         <p>
                                                                                          <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'),this,'Show Solution','Hide Solution')">
                                                                                           Show Solution
                                                                                          </a>
                                                                                          <div class="wpsolution" id="cpp_solution_id_9" style="display:none">
                                                                                           <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include "Random.h"

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };
        static constexpr std::array suits { 'C', 'D', 'H', 'S' };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

class Deck
{
private:
    std::array&lt;Card, 52&gt; m_cards {};
    std::size_t m_nextCardIndex { 0 };

public:
    Deck()
    {
        std::size_t count { 0 };
        for (auto suit: Card::allSuits)
            for (auto rank: Card::allRanks)
                m_cards[count++] = Card{rank, suit};
    }

    void shuffle()
    {
        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
        m_nextCardIndex = 0;
    }

    Card dealCard()
    {
        assert(m_nextCardIndex != 52 &amp;&amp; "Deck::dealCard ran out of cards");
        return m_cards[m_nextCardIndex++];
    }
};

int main()
{
    Deck deck{};
    std::cout &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; '\n';

    deck.shuffle();
    std::cout &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; '\n';

    return 0;
}</code></pre>
                                                                                          </div>
                                                                                          <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                                           Question #4
                                                                                           <p>
                                                                                            Alright, now let’s use our Card and Deck to implement a simplified version of Blackjack! If you’re not already familiar with Blackjack, the Wikipedia article for
                                                                                            <a href="https://en.wikipedia.org/wiki/Blackjack">
                                                                                             Blackjack
                                                                                            </a>
                                                                                            has a summary.
                                                                                            <p>
                                                                                             Here are the rules for our version of Blackjack:
                                                                                             <ul>
                                                                                              <li>
                                                                                               The dealer gets one card to start (in real life, the dealer gets two, but one is face down so it doesn’t matter at this point).
                                                                                               <li>
                                                                                                The player gets two cards to start.
                                                                                                <li>
                                                                                                 The player goes first.
                                                                                                 <li>
                                                                                                  A player can repeatedly “hit” or “stand”.
                                                                                                  <li>
                                                                                                   If the player “stands”, their turn is over, and their score is calculated based on the cards they have been dealt.
                                                                                                   <li>
                                                                                                    If the player “hits”, they get another card and the value of that card is added to their total score.
                                                                                                    <li>
                                                                                                     An ace normally counts as a 1 or an 11 (whichever is better for the total score). For simplicity, we’ll count it as an 11 here.
                                                                                                     <li>
                                                                                                      If the player goes over a score of 21, they bust and lose immediately.
                                                                                                      <li>
                                                                                                       When the player is done, it is the dealer’s turn.
                                                                                                       <li>
                                                                                                        The dealer repeatedly draws until they reach a score of 17 or more, at which point they must stop drawing.
                                                                                                        <li>
                                                                                                         If the dealer goes over a score of 21, they bust and the player wins immediately.
                                                                                                         <li>
                                                                                                          Otherwise, if the player has a higher score than the dealer, the player wins. Otherwise, the player loses (we’ll consider ties as dealer wins for simplicity).
                                                                                                         </li>
                                                                                                        </li>
                                                                                                       </li>
                                                                                                      </li>
                                                                                                     </li>
                                                                                                    </li>
                                                                                                   </li>
                                                                                                  </li>
                                                                                                 </li>
                                                                                                </li>
                                                                                               </li>
                                                                                              </li>
                                                                                             </ul>
                                                                                             <p>
                                                                                              In our simplified version of Blackjack, we’re not going to keep track of which specific cards the player and the dealer have been dealt. We’ll only track the sum of the values of the cards they have been dealt for the player and dealer. This keeps things simpler.
                                                                                              <p>
                                                                                               Start with the code you wrote in the prior quiz (or use our reference solution).
                                                                                               <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                                                &gt; Step #1
                                                                                                <p>
                                                                                                 Create a struct named
                                                                                                 <code>
                                                                                                  Player
                                                                                                 </code>
                                                                                                 that will represent a participant in our game (either the dealer or the player). Since in this game we only care about a player’s score, this struct only needs one member.
                                                                                                 <p>
                                                                                                  Write a function that will (eventually) play a round of Blackjack. For now, this function should draw one randomized card for the dealer and two randomized cards for the player. It should return a bool value indicating who has the greater score.
                                                                                                  <p>
                                                                                                   The code should output the following:
                                                                                                   <pre>The dealer is showing: 10
You have score: 13
You win!
</pre>
                                                                                                   <pre>The dealer is showing: 10
You have score: 8
You lose!
</pre>
                                                                                                   <p>
                                                                                                    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_10'),this,'Show Solution','Hide Solution')">
                                                                                                     Show Solution
                                                                                                    </a>
                                                                                                    <div class="wpsolution" id="cpp_solution_id_10" style="display:none">
                                                                                                     <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include "Random.h"

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };
        static constexpr std::array suits { 'C', 'D', 'H', 'S' };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

class Deck
{
private:
    std::array&lt;Card, 52&gt; m_cards {};
    std::size_t m_nextCardIndex { 0 };

public:
    Deck()
    {
        std::size_t count { 0 };
        for (auto suit: Card::allSuits)
            for (auto rank: Card::allRanks)
                m_cards[count++] = Card{rank, suit};
    }

    void shuffle()
    {
        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
        m_nextCardIndex = 0;
    }

    Card dealCard()
    {
        assert(m_nextCardIndex != 52 &amp;&amp; "Deck::dealCard ran out of cards");
        return m_cards[m_nextCardIndex++];
    }
};

struct Player
{
    int score{};
};

bool playBlackjack()
{
    Deck deck{};
    deck.shuffle();

    Player dealer{ deck.dealCard().value() };

    std::cout &lt;&lt; "The dealer is showing: " &lt;&lt; dealer.score &lt;&lt; '\n';

    Player player { deck.dealCard().value() + deck.dealCard().value() };

    std::cout &lt;&lt; "You have score: " &lt;&lt; player.score &lt;&lt; '\n';

    return (player.score &gt; dealer.score);
}

int main()
{
    if (playBlackjack())
    {
        std::cout &lt;&lt; "You win!\n";
    }
    else
    {
        std::cout &lt;&lt; "You lose!\n";
    }

    return 0;
}</code></pre>
                                                                                                    </div>
                                                                                                    <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                                                     &gt; Step #2
                                                                                                     <p>
                                                                                                      Add a
                                                                                                      <code>
                                                                                                       Settings
                                                                                                      </code>
                                                                                                      namespace that contains two constants: the value above which the player busts, and the value where the dealer must stop drawing cards.
                                                                                                      <p>
                                                                                                       Add the logic that handles the dealer’s turn. The dealer will draw cards until they hit 17, then they must stop. If they bust, the player wins.
                                                                                                       <p>
                                                                                                        Here is some sample output:
                                                                                                        <pre>The dealer is showing: 8
You have score: 9
The dealer flips a 4D.  They now have: 12
The dealer flips a JS.  They now have: 22
The dealer went bust!
You win!
</pre>
                                                                                                        <pre>The dealer is showing: 6
You have score: 13
The dealer flips a 3D.  They now have: 9
The dealer flips a 3H.  They now have: 12
The dealer flips a 9S.  They now have: 21
You lose!
</pre>
                                                                                                        <pre>The dealer is showing: 7
You have score: 21
The dealer flips a JC.  They now have: 17
You win!
</pre>
                                                                                                        <p>
                                                                                                         <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_11'),this,'Show Solution','Hide Solution')">
                                                                                                          Show Solution
                                                                                                         </a>
                                                                                                         <div class="wpsolution" id="cpp_solution_id_11" style="display:none">
                                                                                                          <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include "Random.h"

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };
        static constexpr std::array suits { 'C', 'D', 'H', 'S' };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

class Deck
{
private:
    std::array&lt;Card, 52&gt; m_cards {};
    std::size_t m_nextCardIndex { 0 };

public:
    Deck()
    {
        std::size_t count { 0 };
        for (auto suit: Card::allSuits)
            for (auto rank: Card::allRanks)
                m_cards[count++] = Card{rank, suit};
    }

    void shuffle()
    {
        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
        m_nextCardIndex = 0;
    }

    Card dealCard()
    {
        assert(m_nextCardIndex != 52 &amp;&amp; "Deck::dealCard ran out of cards");
        return m_cards[m_nextCardIndex++];
    }

};

struct Player
{
    int score{};
};

namespace Settings
{
    // Maximum score before losing.
    constexpr int bust{ 21 };

    // Minium score that the dealer has to have.
    constexpr int dealerStopsAt{ 17 };
}

// Returns true if the dealer went bust. False otherwise.
bool dealerTurn(Deck&amp; deck, Player&amp; dealer)
{
    while (dealer.score &lt; Settings::dealerStopsAt)
    {
        Card card { deck.dealCard() };
        dealer.score += card.value();
        std::cout &lt;&lt; "The dealer flips a " &lt;&lt; card &lt;&lt; ".  They now have: " &lt;&lt; dealer.score &lt;&lt; '\n';
    }

    if (dealer.score &gt; Settings::bust)
    {
        std::cout &lt;&lt; "The dealer went bust!\n";
        return true;
    }
    
    return false;
}

bool playBlackjack()
{
    Deck deck{};
    deck.shuffle();

    Player dealer{ deck.dealCard().value() };

    std::cout &lt;&lt; "The dealer is showing: " &lt;&lt; dealer.score &lt;&lt; '\n';

    Player player { deck.dealCard().value() + deck.dealCard().value() };

    std::cout &lt;&lt; "You have score: " &lt;&lt; player.score &lt;&lt; '\n';

    if (dealerTurn(deck, dealer))
        return true;

    return (player.score &gt; dealer.score);
}

int main()
{
    if (playBlackjack())
    {
        std::cout &lt;&lt; "You win!\n";
    }
    else
    {
        std::cout &lt;&lt; "You lose!\n";
    }

    return 0;
}</code></pre>
                                                                                                         </div>
                                                                                                         <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                                                          &gt; Step #3
                                                                                                          <p>
                                                                                                           Finally, add logic for the player’s turn. This will complete the game.
                                                                                                           <p>
                                                                                                            Here is some sample output:
                                                                                                            <pre>The dealer is showing: 2
You have score: 14
(h) to hit, or (s) to stand: h
You were dealt KH.  You now have: 24
You went bust!
You lose!
</pre>
                                                                                                            <pre>The dealer is showing: 10
You have score: 9
(h) to hit, or (s) to stand: h
You were dealt TH.  You now have: 19
(h) to hit, or (s) to stand: s
The dealer flips a 3D.  They now have: 13
The dealer flips a 7H.  They now have: 20
You lose!
</pre>
                                                                                                            <pre>The dealer is showing: 7
You have score: 12
(h) to hit, or (s) to stand: h
You were dealt 7S.  You now have: 19
(h) to hit, or (s) to stand: h
You were dealt 2D.  You now have: 21
(h) to hit, or (s) to stand: s
The dealer flips a 6H.  They now have: 13
The dealer flips a QC.  They now have: 23
The dealer went bust!
You win!
</pre>
                                                                                                            <p>
                                                                                                             <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_12'),this,'Show Solution','Hide Solution')">
                                                                                                              Show Solution
                                                                                                             </a>
                                                                                                             <div class="wpsolution" id="cpp_solution_id_12" style="display:none">
                                                                                                              <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include "Random.h"

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };
        static constexpr std::array suits { 'C', 'D', 'H', 'S' };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

class Deck
{
private:
    std::array&lt;Card, 52&gt; m_cards {};
    std::size_t m_nextCardIndex { 0 };

public:
    Deck()
    {
        std::size_t count { 0 };
        for (auto suit: Card::allSuits)
            for (auto rank: Card::allRanks)
                m_cards[count++] = Card{rank, suit};
    }

    void shuffle()
    {
        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
        m_nextCardIndex = 0;
    }

    Card dealCard()
    {
        assert(m_nextCardIndex != 52 &amp;&amp; "Deck::dealCard ran out of cards");
        return m_cards[m_nextCardIndex++];
    }

};

struct Player
{
    int score{};
};

namespace Settings
{
    // Maximum score before losing.
    constexpr int bust{ 21 };

    // Minium score that the dealer has to have.
    constexpr int dealerStopsAt{ 17 };
}

bool playerWantsHit()
{
    while (true)
    {
        std::cout &lt;&lt; "(h) to hit, or (s) to stand: ";

        char ch{};
        std::cin &gt;&gt; ch;

        switch (ch)
        {
            case 'h':
                return true;
            case 's':
                return false;
        }
    }
}

// Returns true if the player went bust. False otherwise.
bool playerTurn(Deck&amp; deck, Player&amp; player)
{
    while (player.score &lt; Settings::bust &amp;&amp; playerWantsHit())
    {
        Card card { deck.dealCard() };
        player.score += card.value();

        std::cout &lt;&lt; "You were dealt " &lt;&lt; card  &lt;&lt; ". You now have: " &lt;&lt; player.score &lt;&lt; '\n';
    }

    if (player.score &gt; Settings::bust)
    {
        std::cout &lt;&lt; "You went bust!\n";
        return true;
    }

    return false;
}

// Returns true if the dealer went bust. False otherwise.
bool dealerTurn(Deck&amp; deck, Player&amp; dealer)
{
    while (dealer.score &lt; Settings::dealerStopsAt)
    {
        Card card { deck.dealCard() };
        dealer.score += card.value();
        std::cout &lt;&lt; "The dealer flips a " &lt;&lt; card &lt;&lt; ".  They now have: " &lt;&lt; dealer.score &lt;&lt; '\n';
    }

    if (dealer.score &gt; Settings::bust)
    {
        std::cout &lt;&lt; "The dealer went bust!\n";
        return true;
    }

    return false;
}

bool playBlackjack()
{
    Deck deck{};
    deck.shuffle();

    Player dealer{ deck.dealCard().value() };

    std::cout &lt;&lt; "The dealer is showing: " &lt;&lt; dealer.score &lt;&lt; '\n';

    Player player { deck.dealCard().value() + deck.dealCard().value() };

    std::cout &lt;&lt; "You have score: " &lt;&lt; player.score &lt;&lt; '\n';

    if (playerTurn(deck, player))
        return false;

    if (dealerTurn(deck, dealer))
        return true;

    return (player.score &gt; dealer.score);
}

int main()
{
    if (playBlackjack())
    {
        std::cout &lt;&lt; "You win!\n";
    }
    else
    {
        std::cout &lt;&lt; "You lose!\n";
    }

    return 0;
}</code></pre>
                                                                                                             </div>
                                                                                                             <p class="cpp-quiz-question cpp-topline" style="clear:both">
                                                                                                              Question #5
                                                                                                              <p>
                                                                                                               a) Describe how you could modify the above program to handle the case where aces can be equal to 1 or 11.
                                                                                                               <p>
                                                                                                                It’s important to note that we’re only keeping track of the sum of the cards, not which specific cards the user has.
                                                                                                                <p>
                                                                                                                 <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_13'),this,'Show Solution','Hide Solution')">
                                                                                                                  Show Solution
                                                                                                                 </a>
                                                                                                                 <div class="wpsolution" id="cpp_solution_id_13" style="display:none">
                                                                                                                  <p>
                                                                                                                   One way would be to keep track of how many aces the player and the dealer got dealt (In the
                                                                                                                   <code>
                                                                                                                    Player
                                                                                                                   </code>
                                                                                                                   <code>
                                                                                                                    struct
                                                                                                                   </code>
                                                                                                                   , as an integer). If either the player or dealer go over 21 and their ace counter is greater than zero, you can reduce their score by 10 (convert an ace from 11 points to 1 point) and “remove” one from the ace counter. This can be done as many times as needed until the ace counter reaches zero.
                                                                                                                  </p>
                                                                                                                 </div>
                                                                                                                 <p>
                                                                                                                  b) In actual blackjack, if the player and dealer have the same score (and the player has not gone bust), the result is a tie and neither wins. Describe how you’d modify the above program to account for this.
                                                                                                                  <p>
                                                                                                                   <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_14'),this,'Show Solution','Hide Solution')">
                                                                                                                    Show Solution
                                                                                                                   </a>
                                                                                                                   <div class="wpsolution" id="cpp_solution_id_14" style="display:none">
                                                                                                                    <p>
                                                                                                                     Our version of
                                                                                                                     <code>
                                                                                                                      playBlackjack()
                                                                                                                     </code>
                                                                                                                     currently returns a bool indicating whether the player won or not. We’ll need to update this function to return three possibilities: Dealer win, Player win, tie. The best way to do this would be to define an enumeration for these three options, and have the function return the appropriate enumerator.
                                                                                                                    </p>
                                                                                                                   </div>
                                                                                                                   <p>
                                                                                                                    c) Extra credit: implement the above two ideas into your blackjack game. Note that you will need to show the dealer’s initial card and the player’s initial two cards so they know whether they have an ace or not.
                                                                                                                    <p>
                                                                                                                     Here’s a sample output:
                                                                                                                     <pre>The dealer is showing JH (10)
You are showing AH 7D (18)
(h) to hit, or (s) to stand: h
You were dealt JD.  You now have: 18
(h) to hit, or (s) to stand: s
The dealer flips a 6C.  They now have: 16
The dealer flips a AD.  They now have: 17
You win!
</pre>
                                                                                                                     <p>
                                                                                                                      <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_15'),this,'Show Solution','Hide Solution')">
                                                                                                                       Show Solution
                                                                                                                      </a>
                                                                                                                      <div class="wpsolution" id="cpp_solution_id_15" style="display:none">
                                                                                                                       <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include "Random.h"

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };
        static constexpr std::array suits { 'C', 'D', 'H', 'S' };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

class Deck
{
private:
    std::array&lt;Card, 52&gt; m_cards {};
    std::size_t m_nextCardIndex { 0 };

public:
    Deck()
    {
        std::size_t count { 0 };
        for (auto suit: Card::allSuits)
            for (auto rank: Card::allRanks)
                m_cards[count++] = Card{rank, suit};
    }

    void shuffle()
    {
        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
        m_nextCardIndex = 0;
    }

    Card dealCard()
    {
        assert(m_nextCardIndex != 52 &amp;&amp; "Deck::dealCard ran out of cards");
        return m_cards[m_nextCardIndex++];
    }

};

class Player
{
private:
    int m_score{ };
    int m_aceCount { 0 };

public:
    // We'll use a function to add the card to the player's score
    // Since we now need to count aces
    void addToScore(Card card)
    {
        m_score += card.value();
        if (card.rank == Card::rank_ace)
            ++m_aceCount;
    }

    void consumeAces(int maxScore)
    {
        while (m_score &gt; maxScore &amp;&amp; m_aceCount &gt; 0)
        {
            m_score -= 10;
            --m_aceCount;
        }
    }

    int score() { return m_score; }
};

namespace Settings
{
    // Maximum score before losing.
    constexpr int bust{ 21 };

    // Minium score that the dealer has to have.
    constexpr int dealerStopsAt{ 17 };
}

bool playerWantsHit()
{
    while (true)
    {
        std::cout &lt;&lt; "(h) to hit, or (s) to stand: ";

        char ch{};
        std::cin &gt;&gt; ch;

        switch (ch)
        {
            case 'h':
                return true;
            case 's':
                return false;
        }
    }
}

// Returns true if the player went bust. False otherwise.
bool playerTurn(Deck&amp; deck, Player&amp; player)
{
    while (player.score() &lt; Settings::bust &amp;&amp; playerWantsHit())
    {
        Card card { deck.dealCard() };
        player.addToScore(card);
        player.consumeAces(Settings::bust);

        std::cout &lt;&lt; "You were dealt " &lt;&lt; card  &lt;&lt; ". You now have: " &lt;&lt; player.score() &lt;&lt; '\n';
    }

    if (player.score() &gt; Settings::bust)
    {
        std::cout &lt;&lt; "You went bust!\n";
        return true;
    }

    return false;
}


// Returns true if the dealer went bust. False otherwise.
bool dealerTurn(Deck&amp; deck, Player&amp; dealer)
{
    while (dealer.score() &lt; Settings::dealerStopsAt)
    {
        Card card { deck.dealCard() };
        dealer.addToScore(card);
        dealer.consumeAces(Settings::bust);

        std::cout &lt;&lt; "The dealer flips a " &lt;&lt; card &lt;&lt; ".  They now have: " &lt;&lt; dealer.score() &lt;&lt; '\n';
    }

    if (dealer.score() &gt; Settings::bust)
    {
        std::cout &lt;&lt; "The dealer went bust!\n";
        return true;
    }

    return false;
}

enum class GameResult
{
    playerWon,
    dealerWon,
    tie
};

GameResult playBlackjack()
{
    Deck deck{};
    deck.shuffle();

    Player dealer{};
    Card card1 { deck.dealCard() };
    dealer.addToScore(card1);
    std::cout &lt;&lt; "The dealer is showing " &lt;&lt; card1 &lt;&lt; " (" &lt;&lt; dealer.score() &lt;&lt; ")\n";

    Player player{};
    Card card2 { deck.dealCard() };
    Card card3 { deck.dealCard() };
    player.addToScore(card2);
    player.addToScore(card3);
    std::cout &lt;&lt; "You are showing " &lt;&lt; card2 &lt;&lt; ' ' &lt;&lt; card3 &lt;&lt; " (" &lt;&lt; player.score() &lt;&lt; ")\n";

    if (playerTurn(deck, player)) // if player busted
        return GameResult::dealerWon;

    if (dealerTurn(deck, dealer)) // if dealer busted
        return GameResult::playerWon;

    if (player.score() == dealer.score())
        return GameResult::tie;
    
    return (player.score() &gt; dealer.score() ? GameResult::playerWon : GameResult::dealerWon);
}

int main()
{
    switch (playBlackjack())
    {
    case GameResult::playerWon:
        std::cout &lt;&lt; "You win!\n";
        return 0;
    case GameResult::dealerWon:
        std::cout &lt;&lt; "You lose!\n";
        return 0;
    case GameResult::tie:
        std::cout &lt;&lt; "It's a tie.\n";
        return 0;
    }

    return 0;
}</code></pre>
                                                                                                                      </div>
                                                                                                                     </p>
                                                                                                                    </p>
                                                                                                                   </p>
                                                                                                                  </p>
                                                                                                                 </p>
                                                                                                                </p>
                                                                                                               </p>
                                                                                                              </p>
                                                                                                             </p>
                                                                                                            </p>
                                                                                                           </p>
                                                                                                          </p>
                                                                                                         </p>
                                                                                                        </p>
                                                                                                       </p>
                                                                                                      </p>
                                                                                                     </p>
                                                                                                    </p>
                                                                                                   </p>
                                                                                                  </p>
                                                                                                 </p>
                                                                                                </p>
                                                                                               </p>
                                                                                              </p>
                                                                                             </p>
                                                                                            </p>
                                                                                           </p>
                                                                                          </p>
                                                                                         </p>
                                                                                        </p>
                                                                                       </p>
                                                                                      </p>
                                                                                     </p>
                                                                                    </p>
                                                                                   </p>
                                                                                  </p>
                                                                                 </p>
                                                                                </p>
                                                                               </p>
                                                                              </p>
                                                                             </p>
                                                                            </p>
                                                                           </p>
                                                                          </p>
                                                                         </p>
                                                                        </p>
                                                                       </p>
                                                                      </p>
                                                                     </p>
                                                                    </p>
                                                                   </p>
                                                                  </p>
                                                                 </p>
                                                                </p>
                                                               </p>
                                                              </p>
                                                             </p>
                                                            </p>
                                                           </p>
                                                          </p>
                                                         </p>
                                                        </p>
                                                       </p>
                                                      </p>
                                                     </p>
                                                    </p>
                                                   </p>
                                                  </p>
                                                 </p>
                                                </p>
                                               </p>
                                              </p>
                                             </p>
                                            </p>
                                           </p>
                                          </p>
                                         </p>
                                        </p>
                                       </p>
                                      </p>
                                     </p>
                                    </p>
                                   </p>
                                  </p>
                                 </p>
                                </p>
                               </p>
                              </p>
                             </p>
                            </p>
                           </p>
                          </p>
                         </p>
                        </p>
                       </p>
                      </p>
                     </p>
                    </p>
                   </p>
                  </p>
                 </p>
                </p>
               </p>
              </p>
             </p>
            </p>
           </p>
          </p>
         </p>
        </p>
       </p>
      </p>
     </p>
    </p>
   </p>
  </p>
 </div>
</div>
