<div class="article-inner">
 <header>
  <div class="entry-meta beforetitle-meta">
  </div>
  <!-- .entry-meta -->
  <h1 class="entry-title singular-title" itemprop="headline">
   20.x — Chapter 20 summary and quiz
  </h1>
  <div class="entry-meta aftertitle-meta">
  </div>
  <!-- .entry-meta -->
 </header>
 <div class="entry-content" itemprop="articleBody">
  <p class="cpp-section">
   Chapter Review
  </p>
  <p>
   Another chapter down!  There’s just this pesky quiz to get past…
  </p>
  <p>
   Function arguments can be passed by value, reference or address.  Use pass by value for fundamental data types and enumerators.  Use pass by reference for structs, classes, or when you need the function to modify an argument.  Use pass by address for passing pointers or built-in arrays.  Make your pass by reference and address parameters const whenever possible.
  </p>
  <p>
   Values can be returned by value, reference, or address.  Most of the time, return by value is fine, however return by reference or address can be useful when working with dynamically allocated data, structs, or classes.  If returning by reference or address, remember to make sure you’re not returning something that will go out of scope.
  </p>
  <p>
   Function pointers allow us to pass a function to another function.  This can be useful to allow the caller to customize the behavior of a function, such as the way a list gets sorted.
  </p>
  <p>
   Dynamic memory is allocated on the heap.
  </p>
  <p>
   The call stack keeps track of all of the active functions (those that have been called but have not yet terminated) from the start of the program to the current point of execution.  Local variables are allocated on the stack.  The stack has a limited size.  std::vector can be used to implement stack-like behavior.
  </p>
  <p>
   A recursive function is a function that calls itself.  All recursive functions need a termination condition.
  </p>
  <p>
   Command line arguments allow users or other programs to pass data into our program at startup.  Command line arguments are always C-style strings, and have to be converted to numbers if numeric values are desired.
  </p>
  <p>
   Ellipsis allow you to pass a variable number of arguments to a function.  However, ellipsis arguments suspend type checking, and do not know how many arguments were passed.  It is up to the program to keep track of these details.
  </p>
  <p>
   Lambda functions are functions that can be nested inside other functions. They don’t need a name and are very useful in combination with the algorithms library.
  </p>
  <p class="cpp-section cpp-topline" style="clear: both">
   Quiz time
  </p>
  <div class="quiz" style="clear: both">
   <p class="quiz-header">
    Question #1
   </p>
   <p>
    Write function prototypes for the following cases.  Use const if/when necessary.
   </p>
   <p>
    a) A function named max() that takes two doubles and returns the larger of the two.
   </p>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_0" style="display:none">
    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">double max(double x, double y);</code></pre>
   </div>
   <p>
    b) A function named swap() that swaps two integers.
   </p>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_1" style="display:none">
    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">void swap(int&amp; x, int&amp; y);</code></pre>
   </div>
   <p>
    c) A function named getLargestElement() that takes a dynamically allocated array of integers and returns the largest number in such a way that the caller can change the value of the element returned (don’t forget the length parameter).
   </p>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_2" style="display:none">
    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">// Note: array can't be const in this case, because returning a non-const reference to a const element would be a const violation.
int&amp; getLargestElement(int* array, int length);</code></pre>
   </div>
  </div>
  <div class="quiz" style="clear: both">
   <p class="quiz-header">
    Question #2
   </p>
   <p>
    What’s wrong with these programs?
   </p>
   <p>
    a)
   </p>
   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int&amp; doSomething()
{
    int array[]{ 1, 2, 3, 4, 5 };
    return array[3];
}</code></pre>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_3" style="display:none">
    <p>
     doSomething() returns a reference to a local variable that will be destroyed when doSomething terminates.
    </p>
   </div>
   <p>
    b)
   </p>
   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int sumTo(int value)
{
    return value + sumTo(value - 1);
}</code></pre>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_4" style="display:none">
    <p>
     function sumTo () has no termination condition.  Variable value will eventually go negative, and the function will loop infinitely until the stack overflows.
    </p>
   </div>
   <p>
    c)
   </p>
   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">float divide(float x, float y)
{
    return x / y;
}

double divide(float x, float y)
{
    return x / y;
}</code></pre>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_5" style="display:none">
    <p>
     The two divide functions are not distinct, as they have the same name and same parameters.  There is also a potential divide by 0 issue.
    </p>
   </div>
   <p>
    d)
   </p>
   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    int array[100000000]{};

    for (auto x: array)
        std::cout &lt;&lt; x &lt;&lt; ' ';

    std::cout &lt;&lt; '\n';

    return 0;
}</code></pre>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_6" style="display:none">
    <p>
     The array is too large to be allocated on the stack.  It should be dynamically allocated.
    </p>
   </div>
   <p>
    e)
   </p>
   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main(int argc, char* argv[])
{
    int age{ argv[1] };
    std::cout &lt;&lt; "The user's age is " &lt;&lt; age &lt;&lt; '\n';

    return 0;
}</code></pre>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_7" style="display:none">
    <p>
     argv[1] may not exist.  If it does, argv[1] is a string argument, and can’t be converted to an integer via assignment.
    </p>
   </div>
   <p>
   </p>
  </div>
  <div class="quiz" style="clear: both">
   <p class="quiz-header">
    Question #3
   </p>
   <p>
    The best algorithm for determining whether a value exists in a sorted array is called binary search.
   </p>
   <p>
    Binary search works as follows:
   </p>
   <ul>
    <li>
     Look at the center element of the array (if the array has an even number of elements, round down).
    </li>
    <li>
     If the center element is greater than the target element, discard the top half of the array (or recurse on the bottom half)
    </li>
    <li>
     If the center element is less than the target element, discard the bottom half of the array (or recurse on the top half).
    </li>
    <li>
     If the center element equals the target element, return the index of the center element.
    </li>
    <li>
     If you discard the entire array without finding the target element, return a sentinel that represents “not found” (in this case, we’ll use -1, since it’s an invalid array index).
    </li>
   </ul>
   <p>
    Because we can throw out half of the array with each iteration, this algorithm is very fast.  Even with an array of a million elements, it only takes at most 20 iterations to determine whether a value exists in the array or not!  However, it only works on sorted arrays.
   </p>
   <p>
    Modifying an array (e.g. discarding half the elements in an array) is expensive, so typically we do not modify the array.  Instead, we use two integers (min and max) to hold the indices of the minimum and maximum elements of the array that we’re interested in examining.
   </p>
   <p>
    Let’s look at a sample of how this algorithm works, given an array { 3, 6, 7, 9, 12, 15, 18, 21, 24 }, and a target value of 7.  At first, min = 0, max = 8, because we’re searching the whole array (the array is length 9, so the index of the last element is 8).
   </p>
   <ul>
    <li>
     Pass 1) We calculate the midpoint of min (0) and max (8), which is 4.  Element #4 has value 12, which is larger than our target value.  Because the array is sorted, we know that all elements with index equal to or greater than the midpoint (4) must be too large.  So we leave min alone, and set max to 3.
    </li>
    <li>
     Pass 2) We calculate the midpoint of min (0) and max (3), which is 1.  Element #1 has value 6, which is smaller than our target value.  Because the array is sorted, we know that all elements with index equal to or lesser than the midpoint (1) must be too small.  So we set min to 2, and leave max alone.
    </li>
    <li>
     Pass 3) We calculate the midpoint of min (2) and max (3), which is 2.  Element #2 has value 7, which is our target value.  So we return 2.
    </li>
   </ul>
   <p>
    In C++20, calculating the midpoint can be done via calling
    <a href="https://en.cppreference.com/w/cpp/numeric/midpoint">
     <code>
      std::midpoint
     </code>
    </a>
    .  Prior to C++20, you’ll need to calculate the midpoint yourself -- in this case you can use
    <code>
     min + ((max - min) / 2)
    </code>
    to avoid overflow.
   </p>
   <p>
    Given the following code:
   </p>
   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;
#include &lt;iterator&gt;

// array is the array to search over.
// target is the value we're trying to determine exists or not.
// min is the index of the lower bounds of the array we're searching.
// max is the index of the upper bounds of the array we're searching.
// binarySearch() should return the index of the target element if the target is found, -1 otherwise
int binarySearch(const int* array, int target, int min, int max)
{

}

int main()
{
    constexpr int array[]{ 3, 6, 8, 12, 14, 17, 20, 21, 26, 32, 36, 37, 42, 44, 48 };

    // We're going to test a bunch of values to see if they produce the expected results
    constexpr int numTestValues{ 9 };
    // Here are the test values
    constexpr int testValues[numTestValues]{ 0, 3, 12, 13, 22, 26, 43, 44, 49 };
    // And here are the expected results for each value
    int expectedValues[numTestValues]{ -1, 0, 3, -1, -1, 8, -1, 13, -1 };

    // Loop through all of the test values
    for (int count{ 0 }; count &lt; numTestValues; ++count)
    {
        // See if our test value is in the array
        int index{ binarySearch(array, testValues[count], 0, static_cast&lt;int&gt;(std::size(array)) - 1) };
        // If it matches our expected value, then great!
        if (index == expectedValues[count])
             std::cout &lt;&lt; "test value " &lt;&lt; testValues[count] &lt;&lt; " passed!\n";
        else // otherwise, our binarySearch() function must be broken
             std::cout &lt;&lt; "test value " &lt;&lt; testValues[count] &lt;&lt; " failed.  There's something wrong with your code!\n";
    }

    return 0;
}</code></pre>
   <p>
    a) Write an iterative version of the binarySearch function.
   </p>
   <p>
    Hint: You can safely say the target element doesn’t exist when the min index is greater than the max index.
   </p>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_8" style="display:none">
    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt; // for std::midpoint

// array is the array to search over.
// target is the value we're trying to determine exists or not.
// min is the index of the lower bounds of the array we're searching.
// max is the index of the upper bounds of the array we're searching.
// binarySearch() should return the index of the target element if the target is found, -1 otherwise
int binarySearch(const int* array, int target, int min, int max)
{
    assert(array); // make sure array exists

    while (min &lt;= max)
    {
        // implement this iteratively
        int midpoint{ std::midpoint(min, max) };
        // Before C++20
        // int midpoint{ min + ((max-min) / 2) }; // this way of calculating midpoint avoids overflow

        if (array[midpoint] &gt; target)
        {
            // if array[midpoint] &gt; target, then we know the number must be in the lower half of the array
            // we can use midpoint - 1 as the upper index, since we don't need to retest the midpoint next iteration
            max = midpoint - 1;
        }
        else if (array[midpoint] &lt; target)
        {
            // if array[midpoint] &lt; target, then we know the number must be in the upper half of the array
            // we can use midpoint + 1 as the lower index, since we don't need to retest the midpoint next iteration
            min = midpoint + 1;
        }
        else
        {
            return midpoint;
        }
    }
    
    return -1;
}</code></pre>
   </div>
   <p>
    b) Write a recursive version of the binarySearch function.
   </p>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_9" style="display:none">
    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;cassert&gt;
#include &lt;numeric&gt; // for std::midpoint

// array is the array to search over.
// target is the value we're trying to determine exists or not.
// min is the index of the lower bounds of the array we're searching.
// max is the index of the upper bounds of the array we're searching.
// binarySearch() should return the index of the target element if the target is found, -1 otherwise
int binarySearch(const int* array, int target, int min, int max)
{
    assert(array); // make sure array exists

    // implement this recursively

    if (min &gt; max)
        return -1;

    int midpoint{ std::midpoint(min, max) };
    // Before C++20
    // int midpoint{ min + ((max-min) / 2) }; // this way of calculating midpoint avoids overflow

    if (array[midpoint] &gt; target)
    {
        return binarySearch(array, target, min, midpoint - 1);
    }
    else if (array[midpoint] &lt; target)
    {
        return binarySearch(array, target, midpoint + 1, max);
    }

    return midpoint;
}</code></pre>
   </div>
   <div class="cpp-note cpp-lightbluebackground">
    <p class="cpp-note-title cpp-bottomline">
     Tip
    </p>
    <p>
     <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">
      <code>
       std::binary_search
      </code>
     </a>
     returns true if a value exists in a sorted list.
     <br/>
     <a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">
      <code>
       std::equal_range
      </code>
     </a>
     returns the iterators to the first and last element with a given value.
    </p>
    <p>
     Don’t use these functions to solve the quiz, but use them in the future if you need a binary search.
    </p>
   </div>
   <p>
   </p>
  </div>
  <!-- AI CONTENT END 1 -->
 </div>
 <!-- .entry-content -->
 <!-- .entry-utility -->
</div>
