<div class="article-inner">
 <header>
  <div class="entry-meta beforetitle-meta">
  </div>
  <h1 class="entry-title singular-title" itemprop="headline">
   24.x — Chapter 24 summary and quiz
  </h1>
  <div class="entry-meta aftertitle-meta">
  </div>
 </header>
 <div class="entry-content" itemprop="articleBody">
  <p class="cpp-section cpp-topline" style="clear:both">
   Summary
   <p>
    Inheritance allows us to model an is-a relationship between two objects. The object being inherited from is called the parent class, base class, or superclass. The object doing the inheriting is called the child class, derived class, or subclass.
    <p>
     When a derived class inherits from a base class, the derived class acquires all of the members of the base class.
     <p style="clear:both">
      <p>
       <p>
        When a derived class is constructed, the base portion of the class is constructed first, and then the derived portion is constructed. In more detail:
        <ol>
         <li>
          Memory for the derived class is set aside (enough for both the base and derived portions).
          <li>
           The appropriate derived class constructor is called.
           <li>
            The base class object is constructed first using the appropriate base class constructor. If no base class constructor is specified, the default constructor will be used.
            <li>
             The initialization list of the derived class initializes members of the derived class.
             <li>
              The body of the derived class constructor executes.
              <li>
               Control is returned to the caller.
              </li>
             </li>
            </li>
           </li>
          </li>
         </li>
        </ol>
        <p>
         Destruction happens in the opposite order, from most-derived to most-base class.
         <p>
          C++ has 3 access specifiers: public, private, and protected. The protected access specifier allows the class the member belongs to, friends, and derived classes to access protected members, but not the public.
          <p>
           Classes can inherit from another class publicly, privately, or protectedly. Classes almost always inherit publicly.
           <p>
            Here’s a table of all of the access specifier and inheritance types combinations:
            <div class="cpp-table-wrapper">
             <p>
              <p>
               <table class="cpp-table">
                <tbody>
                 <tr>
                  <th>
                   Access specifier in base class
                   <th>
                    Access specifier when inherited publicly
                    <th>
                     Access specifier when inherited privately
                     <th>
                      Access specifier when inherited protectedly
                      <tr>
                       <td>
                        Public
                        <td>
                         Public
                         <td>
                          Private
                          <td>
                           Protected
                           <tr>
                            <td>
                             Private
                             <td>
                              Inaccessible
                              <td>
                               Inaccessible
                               <td>
                                Inaccessible
                                <tr>
                                 <td>
                                  Protected
                                  <td>
                                   Protected
                                   <td>
                                    Private
                                    <td>
                                     Protected
                                    </td>
                                   </td>
                                  </td>
                                 </td>
                                </tr>
                               </td>
                              </td>
                             </td>
                            </td>
                           </tr>
                          </td>
                         </td>
                        </td>
                       </td>
                      </tr>
                     </th>
                    </th>
                   </th>
                  </th>
                 </tr>
                </tbody>
               </table>
              </p>
             </p>
            </div>
            <p>
             Derived classes can add new functions, change the way functions that exist in the base class work in the derived class, change an inherited member’s access level, or hide functionality.
             <p>
              Multiple inheritance enables a derived class to inherit members from more than one parent. You should generally avoid multiple inheritance unless alternatives lead to more complexity.
              <p class="cpp-section cpp-topline" style="clear:both">
               Quiz time
               <div class="quiz" style="clear:both">
                <p class="quiz-header">
                 Question #1
                 <p>
                  For each of the following programs, determine what they output, or if they would not compile, indicate why. This exercise is meant to be done by inspection, so do not compile these (otherwise the answers are trivial).
                  <p>
                   a)
                   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

class Base
{
public:
	Base()
	{
		std::cout &lt;&lt; "Base()\n";
	}
	~Base()
	{
		std::cout &lt;&lt; "~Base()\n";
	}
};

class Derived: public Base
{
public:
	Derived()
	{
		std::cout &lt;&lt; "Derived()\n";
	}
	~Derived()
	{
		std::cout &lt;&lt; "~Derived()\n";
	}
};

int main()
{
	Derived d;

	return 0;
}</code></pre>
                   <p>
                    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">
                     Show Solution
                    </a>
                    <div class="wpsolution" id="cpp_solution_id_0" style="display:none">
                     <p>
                      Construction happens in order from most-Parent to most-Child. Destruction happens in the opposite order.
                      <pre>Base()
Derived()
~Derived()
~Base()
</pre>
                     </p>
                    </div>
                    <p>
                     b)
                     <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

class Base
{
public:
	Base()
	{
		std::cout &lt;&lt; "Base()\n";
	}
	~Base()
	{
		std::cout &lt;&lt; "~Base()\n";
	}
};

class Derived: public Base
{
public:
	Derived()
	{
		std::cout &lt;&lt; "Derived()\n";
	}
	~Derived()
	{
		std::cout &lt;&lt; "~Derived()\n";
	}
};

int main()
{
	Derived d;
	Base b;

	return 0;
}</code></pre>
                     <p>
                      Hint: Local variables are destroyed in the opposite order of definition.
                      <p>
                       <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">
                        Show Solution
                       </a>
                       <div class="wpsolution" id="cpp_solution_id_1" style="display:none">
                        <p>
                         First we construct d, which prints:
                         <pre>Base()
Derived()
</pre>
                         <p>
                          Then we construct b, which prints:
                          <pre>Base()
</pre>
                          <p>
                           Then we destruct b, which prints:
                           <pre>~Base()
</pre>
                           <p>
                            Then we destruct d, which prints:
                            <pre>~Derived()
~Base()
</pre>
                           </p>
                          </p>
                         </p>
                        </p>
                       </div>
                       <p>
                        c)
                        <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

class Base
{
private:
	int m_x {};
public:
	Base(int x): m_x{ x }
	{
		std::cout &lt;&lt; "Base()\n";
	}
	~Base()
	{
		std::cout &lt;&lt; "~Base()\n";
	}

	void print() const { std::cout &lt;&lt; "Base: " &lt;&lt; m_x &lt;&lt; '\n';  }
};

class Derived: public Base
{
public:
	Derived(int y):  Base{ y }
	{
		std::cout &lt;&lt; "Derived()\n";
	}
	~Derived()
	{
		std::cout &lt;&lt; "~Derived()\n";
	}

	void print() const { std::cout &lt;&lt; "Derived: " &lt;&lt; m_x &lt;&lt; '\n'; }
};

int main()
{
	Derived d{ 5 };
	d.print();

	return 0;
}</code></pre>
                        <p>
                         <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">
                          Show Solution
                         </a>
                         <div class="wpsolution" id="cpp_solution_id_2" style="display:none">
                          <p>
                           Doesn’t compile, Derived::print() can’t access private member m_x
                          </p>
                         </div>
                         <p>
                          d)
                          <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

class Base
{
protected:
	int m_x {};
public:
	Base(int x): m_x{ x }
	{
		std::cout &lt;&lt; "Base()\n";
	}
	~Base()
	{
		std::cout &lt;&lt; "~Base()\n";
	}

	void print() const { std::cout &lt;&lt; "Base: " &lt;&lt; m_x &lt;&lt; '\n';  }
};

class Derived: public Base
{
public:
	Derived(int y):  Base{ y }
	{
		std::cout &lt;&lt; "Derived()\n";
	}
	~Derived()
	{
		std::cout &lt;&lt; "~Derived()\n";
	}

	void print() const { std::cout &lt;&lt; "Derived: " &lt;&lt; m_x &lt;&lt; '\n'; }
};

int main()
{
	Derived d{ 5 };
	d.print();

	return 0;
}</code></pre>
                          <p>
                           <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">
                            Show Solution
                           </a>
                           <div class="wpsolution" id="cpp_solution_id_3" style="display:none">
                            <pre>Base()
Derived()
Derived: 5
~Derived()
~Base()
</pre>
                           </div>
                           <p>
                            e)
                            <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

class Base
{
protected:
	int m_x {};
public:
	Base(int x): m_x{ x }
	{
		std::cout &lt;&lt; "Base()\n";
	}
	~Base()
	{
		std::cout &lt;&lt; "~Base()\n";
	}

	void print() const { std::cout &lt;&lt; "Base: " &lt;&lt; m_x &lt;&lt; '\n';  }
};

class Derived: public Base
{
public:
	Derived(int y):  Base{ y }
	{
		std::cout &lt;&lt; "Derived()\n";
	}
	~Derived()
	{
		std::cout &lt;&lt; "~Derived()\n";
	}

	void print() const { std::cout &lt;&lt; "Derived: " &lt;&lt; m_x &lt;&lt; '\n'; }
};

class D2 : public Derived
{
public:
	D2(int z): Derived{ z }
	{
		std::cout &lt;&lt; "D2()\n";
	}
	~D2()
	{
		std::cout &lt;&lt; "~D2()\n";
	}

        // note: no print() function here
};

int main()
{
	D2 d{ 5 };
	d.print();

	return 0;
}</code></pre>
                            <p>
                             <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">
                              Show Solution
                             </a>
                             <div class="wpsolution" id="cpp_solution_id_4" style="display:none">
                              <p>
                               Base()
                               <br/>
                               Derived()
                               <br/>
                               D2()
                               <br/>
                               Derived: 5
                               <br/>
                               ~D2()
                               <br/>
                               ~Derived()
                               <br/>
                               ~Base()
                              </p>
                             </div>
                             <p>
                             </p>
                            </p>
                           </p>
                          </p>
                         </p>
                        </p>
                       </p>
                      </p>
                     </p>
                    </p>
                   </p>
                  </p>
                 </p>
                </p>
               </div>
               <div class="quiz" style="clear:both">
                <p class="quiz-header">
                 Question #2
                 <p>
                  a) Write an Apple class and a Banana class that are derived from a common Fruit class. Fruit should have two members: a name and a color.
                  <p>
                   The following program should run:
                   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int main()
{
	Apple a{ "red" };
	Banana b{};

	std::cout &lt;&lt; "My " &lt;&lt; a.getName() &lt;&lt; " is " &lt;&lt; a.getColor() &lt;&lt; ".\n";
	std::cout &lt;&lt; "My " &lt;&lt; b.getName() &lt;&lt; " is " &lt;&lt; b.getColor() &lt;&lt; ".\n";
	
	return 0;
}</code></pre>
                   <p>
                    And produce the result:
                    <pre>My apple is red.
My banana is yellow.
</pre>
                    <p>
                     <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">
                      Show Solution
                     </a>
                     <div class="wpsolution" id="cpp_solution_id_5" style="display:none">
                      <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

class Fruit
{
private:
	std::string m_name;
	std::string m_color;

public:
	Fruit(std::string_view name, std::string_view color)
		: m_name{ name }, m_color{ color }
	{
	}

	const std::string&amp; getName() const { return m_name; }
	const std::string&amp; getColor() const { return m_color; }
};

class Apple: public Fruit
{
public:
	Apple(std::string_view color="red")
		: Fruit{ "apple", color }
	{
	}
};

class Banana : public Fruit
{
public:
	Banana()
		: Fruit{ "banana", "yellow" }
	{
	}
};

int main()
{
	Apple a{ "red" };
	Banana b;

	std::cout &lt;&lt; "My " &lt;&lt; a.getName() &lt;&lt; " is " &lt;&lt; a.getColor() &lt;&lt; ".\n";
	std::cout &lt;&lt; "My " &lt;&lt; b.getName() &lt;&lt; " is " &lt;&lt; b.getColor() &lt;&lt; ".\n";
	
	return 0;
}</code></pre>
                     </div>
                     <p>
                      b) Add a new class to the previous program called GrannySmith that inherits from Apple.
                      <p>
                       The following program should run:
                       <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int main()
{
	Apple a{ "red" };
	Banana b;
	GrannySmith c;

	std::cout &lt;&lt; "My " &lt;&lt; a.getName() &lt;&lt; " is " &lt;&lt; a.getColor() &lt;&lt; ".\n";
	std::cout &lt;&lt; "My " &lt;&lt; b.getName() &lt;&lt; " is " &lt;&lt; b.getColor() &lt;&lt; ".\n";
	std::cout &lt;&lt; "My " &lt;&lt; c.getName() &lt;&lt; " is " &lt;&lt; c.getColor() &lt;&lt; ".\n";
	
	return 0;
}</code></pre>
                       <p>
                        And produce the result:
                        <pre>My apple is red.
My banana is yellow.
My granny smith apple is green.
</pre>
                        <p>
                         <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">
                          Show Solution
                         </a>
                         <div class="wpsolution" id="cpp_solution_id_6" style="display:none">
                          <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

class Fruit
{
private:
	std::string m_name;
	std::string m_color;

public:
	Fruit(std::string_view name, std::string_view color)
		: m_name{ name }, m_color{ color }
	{
	}

	const std::string&amp; getName() const { return m_name; }
	const std::string&amp; getColor() const { return m_color; }
};

class Apple: public Fruit
{
// The previous constructor we used for Apple had a fixed name ("apple").
// We need a new constructor for GrannySmith to use to set the name of the fruit
protected: // protected so only derived classes can access
	Apple(std::string_view name, std::string_view color)
		: Fruit{ name, color }
	{
	}

public:
	Apple(std::string_view color="red")
		: Fruit{ "apple", color }
	{
	}
};

class Banana : public Fruit
{
public:
	Banana()
		: Fruit{ "banana", "yellow" }
	{
	}
};

class GrannySmith : public Apple
{
public:
	GrannySmith()
		: Apple{ "granny smith apple", "green" }
	{
	}
};

int main()
{
	Apple a{ "red" };
	Banana b;
	GrannySmith c;

	std::cout &lt;&lt; "My " &lt;&lt; a.getName() &lt;&lt; " is " &lt;&lt; a.getColor() &lt;&lt; ".\n";
	std::cout &lt;&lt; "My " &lt;&lt; b.getName() &lt;&lt; " is " &lt;&lt; b.getColor() &lt;&lt; ".\n";
	std::cout &lt;&lt; "My " &lt;&lt; c.getName() &lt;&lt; " is " &lt;&lt; c.getColor() &lt;&lt; ".\n";

	return 0;
}</code></pre>
                         </div>
                        </p>
                       </p>
                      </p>
                     </p>
                    </p>
                   </p>
                  </p>
                 </p>
                </p>
               </div>
               <div class="quiz" style="clear:both">
                <p class="quiz-header">
                 Question #3
                 <p>
                  Challenge time! The following quiz question is more difficult and lengthy. We’re going to write a simple game where you fight monsters. The goal of the game is to collect as much gold as you can before you die or get to level 20.
                  <p>
                   Our program is going to consist of 3 classes: a Creature class, a Player class, and a Monster class. Player and Monster both inherit from Creature.
                   <p>
                    a) First create the Creature class. Creatures have 5 attributes: A name (std::string), a symbol (a char), an amount of health (int), the amount of damage they do per attack (int), and the amount of gold they are carrying (int). Implement these as class members. Write a full set of getters (a get function for each member). Add three other functions: void reduceHealth(int) reduces the Creature’s health by an integer amount. bool isDead() returns true when the Creature’s health is 0 or less. void addGold(int) adds gold to the Creature.
                    <p>
                     The following program should run:
                     <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
	Creature o{ "orc", 'o', 4, 2, 10 };
	o.addGold(5);
	o.reduceHealth(1);
	std::cout &lt;&lt; "The " &lt;&lt; o.getName() &lt;&lt; " has " &lt;&lt; o.getHealth() &lt;&lt; " health and is carrying " &lt;&lt; o.getGold() &lt;&lt; " gold.\n";

	return 0;
}</code></pre>
                     <p>
                      And produce the result:
                      <pre>The orc has 3 health and is carrying 15 gold.
</pre>
                      <p>
                       <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">
                        Show Solution
                       </a>
                       <div class="wpsolution" id="cpp_solution_id_7" style="display:none">
                        <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt; // Requires C++17

class Creature
{
protected:
	std::string m_name;
	char m_symbol {};
	int m_health {};
	int m_damage {};
	int m_gold {};

public:
	Creature(std::string_view name, char symbol, int health, int damage, int gold)
		: m_name{ name }
		, m_symbol{ symbol }
		, m_health{ health }
		, m_damage{ damage }
		, m_gold{ gold }
	{
	}

	const std::string&amp; getName() const { return m_name; }
	char getSymbol() const { return m_symbol; }
	int getHealth() const { return m_health; }
	int getDamage() const { return m_damage; }
	int getGold() const { return m_gold; }

	void reduceHealth(int health) { m_health -= health; }
	bool isDead() const { return m_health &lt;= 0; }
	void addGold(int gold) { m_gold += gold; }
};

int main()
{
	Creature o{ "orc", 'o', 4, 2, 10 };
	o.addGold(5);
	o.reduceHealth(1);
	std::cout &lt;&lt; "The " &lt;&lt; o.getName() &lt;&lt; " has " &lt;&lt; o.getHealth() &lt;&lt; " health and is carrying " &lt;&lt; o.getGold() &lt;&lt; " gold.\n";

	return 0;
}</code></pre>
                       </div>
                       <p>
                        b) Now we’re going to create the Player class. The Player class inherits from Creature. Player has one additional member, the player’s level, which starts at 1. The player has a custom name (entered by the user), uses symbol ‘@’, has 10 health, does 1 damage to start, and has no gold. Write a function called levelUp() that increases the player’s level and damage by 1. Also write a getter for the level member. Finally, write a function called hasWon() that returns true if the player has reached level 20.
                        <p>
                         Write a new main() function that asks the user for their name and produces the output as follows:
                         <pre>Enter your name: Alex
Welcome, Alex.
You have 10 health and are carrying 0 gold.
</pre>
                         <p>
                          <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">
                           Show Solution
                          </a>
                          <div class="wpsolution" id="cpp_solution_id_8" style="display:none">
                           <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt; // std::string_view requires C++17

class Creature
{
protected:
	std::string m_name;
	char m_symbol {};
	int m_health {};
	int m_damage {};
	int m_gold {};

public:
	Creature(std::string_view name, char symbol, int health, int damage, int gold)
		: m_name{ name }
		, m_symbol{ symbol }
		, m_health{ health }
		, m_damage{ damage }
		, m_gold{ gold }
	{
	}

	const std::string&amp; getName() const { return m_name; }
	char getSymbol() const { return m_symbol; }
	int getHealth() const { return m_health; }
	int getDamage() const { return m_damage; }
	int getGold() const { return m_gold; }

	void reduceHealth(int health) { m_health -= health; }
	bool isDead() const { return m_health &lt;= 0; }
	void addGold(int gold) { m_gold += gold; }
};

class Player : public Creature
{
	int m_level{ 1 };

public:
	Player(std::string_view name)
		: Creature{ name, '@', 10, 1, 0 }
	{
	}

	void levelUp()
	{
		++m_level;
		++m_damage;
	}

	int getLevel() const { return m_level; }
	bool hasWon() const { return m_level &gt;= 20; }
};

int main()
{
	std::cout &lt;&lt; "Enter your name: ";
	std::string playerName;
	std::cin &gt;&gt; playerName;

	Player p{ playerName };
	std::cout &lt;&lt; "Welcome, " &lt;&lt; p.getName() &lt;&lt; ".\n";

	std::cout &lt;&lt; "You have " &lt;&lt; p.getHealth() &lt;&lt; " health and are carrying " &lt;&lt; p.getGold() &lt;&lt; " gold.\n";

	return 0;
}</code></pre>
                          </div>
                          <p>
                           c) Next up is the Monster class. Monster also inherits from Creature. Monsters have no non-inherited member variables.
                           <p>
                            First, write an empty Monster class inheriting from Creature, and then add an enum inside the Monster class named Type that contains enumerators for the 3 monsters that we’ll have in this game:
                            <code>
                             dragon
                            </code>
                            ,
                            <code>
                             orc
                            </code>
                            , and
                            <code>
                             slime
                            </code>
                            (you’ll also want a
                            <code>
                             max_types
                            </code>
                            enumerator, as that will come in handy in a bit).
                            <p>
                             <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'),this,'Show Solution','Hide Solution')">
                              Show Solution
                             </a>
                             <div class="wpsolution" id="cpp_solution_id_9" style="display:none">
                              <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">class Monster : public Creature
{
public:
	enum Type
	{
		dragon,
		orc,
		slime,
		max_types
	};
};</code></pre>
                             </div>
                             <p>
                              d) Each Monster type will have a different name, symbol, starting health, gold, and damage. Here is a table of stats for each monster Type:
                              <div class="cpp-table-wrapper">
                               <p>
                                <p>
                                 <table class="cpp-table">
                                  <tbody>
                                   <tr>
                                    <th>
                                     Type
                                     <th>
                                      Name
                                      <th>
                                       Symbol
                                       <th>
                                        Health
                                        <th>
                                         Damage
                                         <th>
                                          Gold
                                          <tr>
                                           <td>
                                            dragon
                                            <td>
                                             dragon
                                             <td>
                                              D
                                              <td>
                                               20
                                               <td>
                                                4
                                                <td>
                                                 100
                                                 <tr>
                                                  <td>
                                                   orc
                                                   <td>
                                                    orc
                                                    <td>
                                                     o
                                                     <td>
                                                      4
                                                      <td>
                                                       2
                                                       <td>
                                                        25
                                                        <tr>
                                                         <td>
                                                          slime
                                                          <td>
                                                           slime
                                                           <td>
                                                            s
                                                            <td>
                                                             1
                                                             <td>
                                                              1
                                                              <td>
                                                               10
                                                              </td>
                                                             </td>
                                                            </td>
                                                           </td>
                                                          </td>
                                                         </td>
                                                        </tr>
                                                       </td>
                                                      </td>
                                                     </td>
                                                    </td>
                                                   </td>
                                                  </td>
                                                 </tr>
                                                </td>
                                               </td>
                                              </td>
                                             </td>
                                            </td>
                                           </td>
                                          </tr>
                                         </th>
                                        </th>
                                       </th>
                                      </th>
                                     </th>
                                    </th>
                                   </tr>
                                  </tbody>
                                 </table>
                                </p>
                               </p>
                              </div>
                              <p>
                               Next step is to write a Monster constructor, so we can create monsters. The Monster constructor should take a Type enum as a parameter, and then create a Monster with the appropriate stats for that kind of monster.
                               <p>
                                There are a number of different ways to implement this (some better, some worse). However in this case, because all of our monster attributes are predefined (not random or customized per creature), we can use a lookup table. Our lookup table will be a C-style array of Creature, where indexing the array with a Type will return the appropriate Creature for that Type.
                                <p>
                                 Since this Creature table is specific to Monster, we can define it inside the Monster class as
                                 <code>
                                  static inline Creature monsterData[] { }
                                 </code>
                                 , initialized with our Creature elements.
                                 <p>
                                  Our Monster constructor is then easy: we can call the Creature copy constructor and pass it the appropriate Creature from our monsterData table.
                                  <p>
                                   The following program should compile:
                                   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
	Monster m{ Monster::Type::orc };
	std::cout &lt;&lt; "A " &lt;&lt; m.getName() &lt;&lt; " (" &lt;&lt; m.getSymbol() &lt;&lt; ") was created.\n";

	return 0;
}</code></pre>
                                   <p>
                                    and print:
                                    <pre>A orc (o) was created.
</pre>
                                    <p>
                                     <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_10'),this,'Show Solution','Hide Solution')">
                                      Show Solution
                                     </a>
                                     <div class="wpsolution" id="cpp_solution_id_10" style="display:none">
                                      <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
 
class Creature
{
protected:
    std::string m_name;
    char m_symbol {};
    int m_health {};
    int m_damage {};
    int m_gold {};
 
public:
     Creature(std::string_view name, char symbol, int health, int damage, int gold)
        : m_name{ name }
        , m_symbol{ symbol }
        , m_health{ health }
        , m_damage{ damage }
        , m_gold{ gold }
    { }
 
    char getSymbol() const { return m_symbol; }
    const std::string&amp; getName() const { return m_name; }
    bool isDead() const { return m_health &lt;= 0; }
    int getGold() const { return m_gold; }
    void addGold(int gold) { m_gold += gold; }
    void reduceHealth(int health) { m_health -= health; }
    int getHealth() const { return m_health; }
    int getDamage() const { return m_damage; }
};
 
class Player : public Creature
{
    int m_level{ 1 };
 
public:
    Player(const std::string&amp; name)
        : Creature{ name, '@', 10, 1, 0 }
    {
    }
 
    void levelUp()
    {
        ++m_level;
        ++m_damage;
    }
 
    int getLevel() const { return m_level; }
    bool hasWon() const { return m_level &gt;= 20; }
};
 
class Monster : public Creature
{
public:
    enum Type
    {
        dragon,
        orc,
        slime,
        max_types
    };
 
private:
    inline static Creature monsterData[] {
        Creature { "dragon", 'D', 20, 4, 100 },
        Creature { "orc", 'o', 4, 2, 25 },
        Creature { "slime", 's', 1, 1, 10 }
        };

    static_assert(std::size(monsterData) == max_types);

public:
    Monster(Type type)
        : Creature{ monsterData[type] }
    {
    }
};
 
int main()
{
    Monster m{ Monster::Type::orc };
    std::cout &lt;&lt; "A " &lt;&lt; m.getName() &lt;&lt; " (" &lt;&lt; m.getSymbol() &lt;&lt; ") was created.\n";
 
  return 0;
}</code></pre>
                                     </div>
                                     <p>
                                      e) Finally, add a
                                      <code>
                                       static
                                      </code>
                                      function to Monster named
                                      <code>
                                       getRandomMonster()
                                      </code>
                                      . This function should pick a random number from
                                      <code>
                                       0
                                      </code>
                                      to
                                      <code>
                                       max_types-1
                                      </code>
                                      and return a monster (by value) with that
                                      <code>
                                       Type
                                      </code>
                                      (you’ll need to
                                      <code>
                                       static_cast
                                      </code>
                                      the
                                      <code>
                                       int
                                      </code>
                                      to a
                                      <code>
                                       Type
                                      </code>
                                      to pass it to the
                                      <code>
                                       Monster
                                      </code>
                                      constructor).
                                      <p>
                                       Lesson
                                       <a href="https://www.learncpp.com/cpp-tutorial/global-random-numbers-random-h/#RandomH">
                                        8.15 -- Global random numbers (Random.h)
                                       </a>
                                       contains code you can use to pick a random number.
                                       <p>
                                        The following main function should run:
                                        <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
	for (int i{ 0 }; i &lt; 10; ++i)
	{
		Monster m{ Monster::getRandomMonster() };
		std::cout &lt;&lt; "A " &lt;&lt; m.getName() &lt;&lt; " (" &lt;&lt; m.getSymbol() &lt;&lt; ") was created.\n";
	}

	return 0;
}</code></pre>
                                        <p>
                                         The results of this program should be randomized.
                                         <p>
                                          <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_11'),this,'Show Solution','Hide Solution')">
                                           Show Solution
                                          </a>
                                          <div class="wpsolution" id="cpp_solution_id_11" style="display:none">
                                           <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include "Random.h" // https://www.learncpp.com/cpp-tutorial/global-random-numbers-random-h/
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
 
class Creature
{
protected:
    std::string m_name;
    char m_symbol {};
    int m_health {};
    int m_damage {};
    int m_gold {};
 
public:
     Creature(std::string_view name, char symbol, int health, int damage, int gold)
        : m_name{ name }
        , m_symbol{ symbol }
        , m_health{ health }
        , m_damage{ damage }
        , m_gold{ gold }
    { }
 
    char getSymbol() const { return m_symbol; }
    const std::string&amp; getName() const { return m_name; }
    bool isDead() const { return m_health &lt;= 0; }
    int getGold() const { return m_gold; }
    void addGold(int gold) { m_gold += gold; }
    void reduceHealth(int health) { m_health -= health; }
    int getHealth() const { return m_health; }
    int getDamage() const { return m_damage; }
};
 
class Player : public Creature
{
    int m_level{ 1 };
 
public:
    Player(const std::string&amp; name)
        : Creature{ name, '@', 10, 1, 0 }
    {
    }
 
    void levelUp()
    {
        ++m_level;
        ++m_damage;
    }
 
    int getLevel() const { return m_level; }
    bool hasWon() const { return m_level &gt;= 20; }
};
 
class Monster : public Creature
{
public:
    enum Type
    {
        dragon,
        orc,
        slime,
        max_types
    };
 
private:
    inline static Creature monsterData[] {
        Creature { "dragon", 'D', 20, 4, 100 },
        Creature { "orc", 'o', 4, 2, 25 },
        Creature { "slime", 's', 1, 1, 10 }
        };

    static_assert(std::size(monsterData) == max_types);

public:
    Monster(Type type)
        : Creature{ monsterData[type] }
    {
    }
 
    static Monster getRandomMonster()
    {
        int num{ Random::get(0, max_types - 1) };
        return Monster{ static_cast&lt;Type&gt;(num) };
    }
};
 
int main()
{
    for (int i{ 0 }; i &lt; 10; ++i)
    {
        Monster m{ Monster::getRandomMonster() };
        std::cout &lt;&lt; "A " &lt;&lt; m.getName() &lt;&lt; " (" &lt;&lt; m.getSymbol() &lt;&lt; ") was created.\n";
    }
 
  return 0;
}</code></pre>
                                          </div>
                                          <p>
                                           f) We’re finally set to write our game logic!
                                           <p>
                                            Here are the rules for the game:
                                            <p>
                                             The player encounters one randomly generated monster at a time.
                                             <br/>
                                             For each monster, the player has two choices: (R)un or (F)ight.
                                             <br/>
                                             If the player decides to Run, they have a 50% chance of escaping.
                                             <br/>
                                             If the player escapes, they move to the next encounter with no ill effects.
                                             <br/>
                                             If the player does not escape, the monster gets a free attack, and the player chooses their next action.
                                             <br/>
                                             If the player chooses to fight, the player attacks first. The monster’s health is reduced by the player’s damage.
                                             <br/>
                                             If the monster dies, the player takes any gold the monster is carrying. The player also levels up, increasing their level and damage by 1.
                                             <br/>
                                             If the monster does not die, the monster attacks the player back. The player’s health is reduced by the monster’s damage.
                                             <br/>
                                             The game ends when the player has died (loss) or reached level 20 (win)
                                             <br/>
                                             If the player dies, the game should tell the player what level they were and how much gold they had.
                                             <br/>
                                             If the player wins, the game should tell the player they won, and how much gold they had
                                             <p>
                                              Here’s a sample game session:
                                              <p>
                                               Enter your name: Alex
                                               <br/>
                                               Welcome, Alex
                                               <br/>
                                               You have encountered a slime (s).
                                               <br/>
                                               (R)un or (F)ight: f
                                               <br/>
                                               You hit the slime for 1 damage.
                                               <br/>
                                               You killed the slime.
                                               <br/>
                                               You are now level 2.
                                               <br/>
                                               You found 10 gold.
                                               <br/>
                                               You have encountered a dragon (D).
                                               <br/>
                                               (R)un or (F)ight: r
                                               <br/>
                                               You failed to flee.
                                               <br/>
                                               The dragon hit you for 4 damage.
                                               <br/>
                                               (R)un or (F)ight: r
                                               <br/>
                                               You successfully fled.
                                               <br/>
                                               You have encountered a orc (o).
                                               <br/>
                                               (R)un or (F)ight: f
                                               <br/>
                                               You hit the orc for 2 damage.
                                               <br/>
                                               The orc hit you for 2 damage.
                                               <br/>
                                               (R)un or (F)ight: f
                                               <br/>
                                               You hit the orc for 2 damage.
                                               <br/>
                                               You killed the orc.
                                               <br/>
                                               You are now level 3.
                                               <br/>
                                               You found 25 gold.
                                               <br/>
                                               You have encountered a dragon (D).
                                               <br/>
                                               (R)un or (F)ight: r
                                               <br/>
                                               You failed to flee.
                                               <br/>
                                               The dragon hit you for 4 damage.
                                               <br/>
                                               You died at level 3 and with 35 gold.
                                               <br/>
                                               Too bad you can’t take it with you!
                                               <p>
                                                Hint: Create 4 functions:
                                                <ul>
                                                 <li>
                                                  The main() function should handle game setup (creating the Player) and the main game loop.
                                                  <li>
                                                   fightMonster() handles the fight between the Player and a single Monster, including asking the player what they want to do, handling the run or fight cases.
                                                   <li>
                                                    attackMonster() handles the player attacking the monster, including leveling up.
                                                    <li>
                                                     attackPlayer() handles the monster attacking the player.
                                                    </li>
                                                   </li>
                                                  </li>
                                                 </li>
                                                </ul>
                                                <p>
                                                 <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_12'),this,'Show Solution','Hide Solution')">
                                                  Show Solution
                                                 </a>
                                                 <div class="wpsolution" id="cpp_solution_id_12" style="display:none">
                                                  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include "Random.h" // https://www.learncpp.com/cpp-tutorial/global-random-numbers-random-h/
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
 
class Creature
{
protected:
    std::string m_name;
    char m_symbol {};
    int m_health {};
    int m_damage {};
    int m_gold {};
 
public:
     Creature(std::string_view name, char symbol, int health, int damage, int gold)
        : m_name{ name }
        , m_symbol{ symbol }
        , m_health{ health }
        , m_damage{ damage }
        , m_gold{ gold }
    { }
 
    char getSymbol() const { return m_symbol; }
    const std::string&amp; getName() const { return m_name; }
    bool isDead() const { return m_health &lt;= 0; }
    int getGold() const { return m_gold; }
    void addGold(int gold) { m_gold += gold; }
    void reduceHealth(int health) { m_health -= health; }
    int getHealth() const { return m_health; }
    int getDamage() const { return m_damage; }
};
 
class Player : public Creature
{
    int m_level{ 1 };
 
public:
    Player(const std::string&amp; name)
        : Creature{ name, '@', 10, 1, 0 }
    {
    }
 
    void levelUp()
    {
        ++m_level;
        ++m_damage;
    }
 
    int getLevel() const { return m_level; }
    bool hasWon() const { return m_level &gt;= 20; }
};
 
class Monster : public Creature
{
public:
    enum Type
    {
        dragon,
        orc,
        slime,
        max_types
    };
 
private:
    inline static Creature monsterData[] {
        Creature { "dragon", 'D', 20, 4, 100 },
        Creature { "orc", 'o', 4, 2, 25 },
        Creature { "slime", 's', 1, 1, 10 }
        };

    static_assert(std::size(monsterData) == max_types);

public:
    Monster(Type type)
        : Creature{ monsterData[type] }
    {
    }
 
    static Monster getRandomMonster()
    {
        int num{ Random::get(0, max_types - 1) };
        return Monster{ static_cast&lt;Type&gt;(num) };
    }
};
 
// This function handles the player attacking the monster
void attackMonster(Player&amp; player, Monster&amp; monster)
{
    // If the player is dead, we can't attack the monster
    if (player.isDead())
        return;

    std::cout &lt;&lt; "You hit the " &lt;&lt; monster.getName() &lt;&lt; " for " &lt;&lt; player.getDamage() &lt;&lt; " damage.\n";

    // Reduce the monster's health by the player's damage
    monster.reduceHealth(player.getDamage());

    // If the monster is now dead, level the player up
    if (monster.isDead())
    {
        std::cout &lt;&lt; "You killed the " &lt;&lt; monster.getName() &lt;&lt; ".\n";
        player.levelUp();
        std::cout &lt;&lt; "You are now level " &lt;&lt; player.getLevel() &lt;&lt; ".\n";
        std::cout &lt;&lt; "You found " &lt;&lt; monster.getGold() &lt;&lt; " gold.\n";
        player.addGold(monster.getGold());
    }
}

// This function handles the monster attacking the player
void attackPlayer(const Monster&amp; monster, Player&amp; player)
{
    // If the monster is dead, it can't attack the player
    if (monster.isDead())
        return;

    // Reduce the player's health by the monster's damage
    player.reduceHealth(monster.getDamage());
    std::cout &lt;&lt; "The " &lt;&lt; monster.getName() &lt;&lt; " hit you for " &lt;&lt; monster.getDamage() &lt;&lt; " damage.\n";
}

// This function handles the entire fight between a player and a randomly generated monster
void fightMonster(Player&amp; player)
{
    // First randomly generate a monster
    Monster monster{ Monster::getRandomMonster() };
    std::cout &lt;&lt; "You have encountered a " &lt;&lt; monster.getName() &lt;&lt; " (" &lt;&lt; monster.getSymbol() &lt;&lt; ").\n";

    // While the monster isn't dead and the player isn't dead, the fight continues
    while (!monster.isDead() &amp;&amp; !player.isDead())
    {
        std::cout &lt;&lt; "(R)un or (F)ight: ";
        char input{};
        std::cin &gt;&gt; input;
        if (input == 'R' || input == 'r')
        {
            // 50% chance of fleeing successfully
            if (Random::get(1, 2) == 1)
            {
                std::cout &lt;&lt; "You successfully fled.\n";
                return; // success ends the encounter
            }
            else
            {
                // Failure to flee gives the monster a free attack on the player
                std::cout &lt;&lt; "You failed to flee.\n";
                attackPlayer(monster, player);
                continue;
            }
        }

        if (input == 'F' || input == 'f')
        {
            // Player attacks first, monster attacks second
            attackMonster(player, monster);
            attackPlayer(monster, player);
        }
    }
}

int main()
{
    std::cout &lt;&lt; "Enter your name: ";
    std::string playerName;
    std::cin &gt;&gt; playerName;

    Player player{ playerName };
    std::cout &lt;&lt; "Welcome, " &lt;&lt; player.getName() &lt;&lt; '\n';

    // If the player isn't dead and hasn't won yet, the game continues
    while (!player.isDead() &amp;&amp; !player.hasWon())
        fightMonster(player);

    // At this point, the player is either dead or has won
    if (player.isDead())
    {
        std::cout &lt;&lt; "You died at level " &lt;&lt; player.getLevel() &lt;&lt; " and with " &lt;&lt; player.getGold() &lt;&lt; " gold.\n";
        std::cout &lt;&lt; "Too bad you can't take it with you!\n";
    }
    else
    {
        std::cout &lt;&lt; "You won the game with " &lt;&lt; player.getGold() &lt;&lt; " gold!\n";
    }

  return 0;
}</code></pre>
                                                 </div>
                                                 <p>
                                                  g) Extra credit:
                                                  <br/>
                                                  Reader
                                                  <a href="https://www.learncpp.com/cpp-tutorial/11-x-chapter-11-comprehensive-quiz/comment-page-5/#comment-471079">
                                                   Tom
                                                  </a>
                                                  didn’t sharpen his sword enough to defeat the mighty dragon. Help him by implementing the following potions in different sizes:
                                                  <div class="cpp-table-wrapper">
                                                   <p>
                                                    <p>
                                                     <table class="cpp-table">
                                                      <tbody>
                                                       <tr>
                                                        <th>
                                                         Type
                                                         <th>
                                                          Effect (Small)
                                                          <th>
                                                           Effect (Medium)
                                                           <th>
                                                            Effect (Large)
                                                            <tr>
                                                             <td>
                                                              Health
                                                              <td>
                                                               +2 Health
                                                               <td>
                                                                +2 Health
                                                                <td>
                                                                 +5 Health
                                                                 <tr>
                                                                  <td>
                                                                   Strength
                                                                   <td>
                                                                    +1 Damage
                                                                    <td>
                                                                     +1 Damage
                                                                     <td>
                                                                      +1 Damage
                                                                      <tr>
                                                                       <td>
                                                                        Poison
                                                                        <td>
                                                                         -1 Health
                                                                         <td>
                                                                          -1 Health
                                                                          <td>
                                                                           -1 Health
                                                                          </td>
                                                                         </td>
                                                                        </td>
                                                                       </td>
                                                                      </tr>
                                                                     </td>
                                                                    </td>
                                                                   </td>
                                                                  </td>
                                                                 </tr>
                                                                </td>
                                                               </td>
                                                              </td>
                                                             </td>
                                                            </tr>
                                                           </th>
                                                          </th>
                                                         </th>
                                                        </th>
                                                       </tr>
                                                      </tbody>
                                                     </table>
                                                    </p>
                                                   </p>
                                                  </div>
                                                  <p>
                                                   Feel free to get creative and add more potions or change their effects!
                                                   <p>
                                                    The player has a 30% chance of finding a potion after every won fight and has the choice between drinking or not drinking it. If the player doesn’t drink the potion, it disappears. The player doesn’t know what type of potion was found until the player drinks it, at which point the type and size of the potion is revealed and the effect is applied.
                                                    <p>
                                                     In the following example, the player found a poison potion and died from drinking it (Poison was much more damaging in this example)
                                                     <pre>You have encountered a slime (s).
(R)un or (F)ight: f
You hit the slime for 1 damage.
You killed the slime.
You are now level 2.
You found 10 gold.
You found a mythical potion! Do you want to drink it? [y/n]: y
You drank a Medium potion of Poison
You died at level 2 and with 10 gold.
Too bad you can't take it with you!
</pre>
                                                     <p>
                                                      <a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">
                                                       Show Hint
                                                      </a>
                                                      <div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">
                                                       Hint: Add a Potion class that has a type and size member variable, along with a member function that returns its name and a static member function the creates a random Potion, similar to the getRandomMonster() function.
                                                       <br/>
                                                       In the Player class, add a drinkPotion() member function the applies the potion’s effect.
                                                      </div>
                                                      <p>
                                                       <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_13'),this,'Show Solution','Hide Solution')">
                                                        Show Solution
                                                       </a>
                                                       <div class="wpsolution" id="cpp_solution_id_13" style="display:none">
                                                        <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include "Random.h" // https://www.learncpp.com/cpp-tutorial/global-random-numbers-random-h/
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

class Potion
{
public:
    // All possible types of potions
    enum Type
    {
        health,
        strength,
        poison,

        // For random potion generation
        max_type
    };

    enum Size
    {
        small,
        medium,
        large,

        max_size
    };


private:
    Type m_type{};
    Size m_size{};

public:
    Potion(Type type, Size size)
        : m_type{ type },
        m_size{ size }
    {
    }

    Type getType() const { return m_type; }
    Size getSize() const { return m_size; }

    // The names of potions are compile-time literals, we can
    // return a std::string_view.
    static std::string_view getPotionTypeName(Type type)
    {
        static constexpr std::string_view names[] {
          "Health",
          "Strength",
          "Poison"
        };

        return names[type];
    }

    static std::string_view getPotionSizeName(Size size)
    {
        static constexpr std::string_view names[] {
          "Small",
          "Medium",
          "Large"
        };

        return names[size];
    }

    std::string getName() const
    {
        // We use a std::stringstream, but this could also be solved using
        // std::string.
        // We first used std::stringstream in lesson 7.13.
        std::stringstream result{};

        result &lt;&lt; getPotionSizeName(getSize()) &lt;&lt; " potion of " &lt;&lt; getPotionTypeName(getType());

        // We can extract the string from an std::stringstream by using the str()
        // member function.
        return result.str();
    }

    static Potion getRandomPotion()
    {
        return Potion{
          static_cast&lt;Type&gt;(Random::get(0, max_type - 1)),
          static_cast&lt;Size&gt;(Random::get(0, max_size - 1))
        };
    }
};

class Creature
{
protected:
    std::string m_name;
    char m_symbol {};
    int m_health {};
    int m_damage {};
    int m_gold {};
 
public:
     Creature(std::string_view name, char symbol, int health, int damage, int gold)
        : m_name{ name }
        , m_symbol{ symbol }
        , m_health{ health }
        , m_damage{ damage }
        , m_gold{ gold }
    { }
 
    char getSymbol() const { return m_symbol; }
    const std::string&amp; getName() const { return m_name; }
    bool isDead() const { return m_health &lt;= 0; }
    int getGold() const { return m_gold; }
    void addGold(int gold) { m_gold += gold; }
    void reduceHealth(int health) { m_health -= health; }
    int getHealth() const { return m_health; }
    int getDamage() const { return m_damage; }
};
 
class Player : public Creature
{
    int m_level{ 1 };
 
public:
    Player(const std::string&amp; name)
        : Creature{ name, '@', 10, 1, 0 }
    {
    }
 
    void levelUp()
    {
        ++m_level;
        ++m_damage;
    }

    // Applies a potion's effect to the player
    void drinkPotion(const Potion&amp; potion)
    {
        switch (potion.getType())
        {
        case Potion::health:
            // Only a health potion's size affects its power. All other
            // potions are independent of size.
            m_health += ((potion.getSize() == Potion::large) ? 5 : 2);
            break;
        case Potion::strength:
            ++m_damage;
            break;
        case Potion::poison:
            reduceHealth(1);
            break;
            // Handle max_type to silence the compiler warning. Don't use default:
            // because we want the compiler to warn us if we add a new potion but
            // forget to implement its effect.
        case Potion::max_type:
            break;
        }
    }

    int getLevel() const { return m_level; }
    bool hasWon() const { return m_level &gt;= 20; }
};
 
class Monster : public Creature
{
public:
    enum Type
    {
        dragon,
        orc,
        slime,
        max_types
    };
 
private:
    inline static Creature monsterData[] {
        Creature { "dragon", 'D', 20, 4, 100 },
        Creature { "orc", 'o', 4, 2, 25 },
        Creature { "slime", 's', 1, 1, 10 }
        };

    static_assert(std::size(monsterData) == max_types);

public:
    Monster(Type type)
        : Creature{ monsterData[type] }
    {
    }
 
    static Monster getRandomMonster()
    {
        int num{ Random::get(0, max_types - 1) };
        return Monster{ static_cast&lt;Type&gt;(num) };
    }
};

// We moved this out of attackMonster() to keep the function shorter.
void onMonsterKilled(Player&amp; player, const Monster&amp; monster)
{
    std::cout &lt;&lt; "You killed the " &lt;&lt; monster.getName() &lt;&lt; ".\n";
    player.levelUp();
    std::cout &lt;&lt; "You are now level " &lt;&lt; player.getLevel() &lt;&lt; ".\n";
    std::cout &lt;&lt; "You found " &lt;&lt; monster.getGold() &lt;&lt; " gold.\n";
    player.addGold(monster.getGold());

    // 30% chance of finding a potion
    constexpr int potionChance{ 30 };
    if (Random::get(1, 100) &lt;= potionChance)
    {
        // Generate a random potion
        auto potion{ Potion::getRandomPotion() };

        std::cout &lt;&lt; "You found a mythical potion! Do you want to drink it? [y/n]: ";
        char choice{};
        std::cin &gt;&gt; choice;

        if (choice == 'Y' || choice == 'y')
        {
            // Apply the effect
            player.drinkPotion(potion);
            // Reveal the potion type and size
            std::cout &lt;&lt; "You drank a " &lt;&lt; potion.getName() &lt;&lt; ".\n";
        }
    }
}

// This function handles the player attacking the monster
void attackMonster(Player&amp; player, Monster&amp; monster)
{
    // If the player is dead, we can't attack the monster
    if (player.isDead())
        return;

    std::cout &lt;&lt; "You hit the " &lt;&lt; monster.getName() &lt;&lt; " for " &lt;&lt; player.getDamage() &lt;&lt; " damage.\n";

    // Reduce the monster's health by the player's damage
    monster.reduceHealth(player.getDamage());

    // If the monster is now dead, level the player up
    if (monster.isDead())
    {
        // Reward the player
        onMonsterKilled(player, monster);
    }
}

// This function handles the monster attacking the player
void attackPlayer(const Monster&amp; monster, Player&amp; player)
{
    // If the monster is dead, it can't attack the player
    if (monster.isDead())
        return;

    // Reduce the player's health by the monster's damage
    player.reduceHealth(monster.getDamage());
    std::cout &lt;&lt; "The " &lt;&lt; monster.getName() &lt;&lt; " hit you for " &lt;&lt; monster.getDamage() &lt;&lt; " damage.\n";
}

// This function handles the entire fight between a player and a randomly generated monster
void fightMonster(Player&amp; player)
{
    // First randomly generate a monster
    Monster monster{ Monster::getRandomMonster() };
    std::cout &lt;&lt; "You have encountered a " &lt;&lt; monster.getName() &lt;&lt; " (" &lt;&lt; monster.getSymbol() &lt;&lt; ").\n";

    // While the monster isn't dead and the player isn't dead, the fight continues
    while (!monster.isDead() &amp;&amp; !player.isDead())
    {
        std::cout &lt;&lt; "(R)un or (F)ight: ";
        char input{};
        std::cin &gt;&gt; input;
        if (input == 'R' || input == 'r')
        {
            // 50% chance of fleeing successfully
            if (Random::get(1, 2) == 1)
            {
                std::cout &lt;&lt; "You successfully fled.\n";
                return; // success ends the encounter
            }
            else
            {
                // Failure to flee gives the monster a free attack on the player
                std::cout &lt;&lt; "You failed to flee.\n";
                attackPlayer(monster, player);
                continue;
            }
        }

        if (input == 'F' || input == 'f')
        {
            // Player attacks first, monster attacks second
            attackMonster(player, monster);
            attackPlayer(monster, player);
        }
    }
}

int main()
{
    std::cout &lt;&lt; "Enter your name: ";
    std::string playerName;
    std::cin &gt;&gt; playerName;

    Player player{ playerName };
    std::cout &lt;&lt; "Welcome, " &lt;&lt; player.getName() &lt;&lt; '\n';

    // If the player isn't dead and hasn't won yet, the game continues
    while (!player.isDead() &amp;&amp; !player.hasWon())
        fightMonster(player);

    // At this point, the player is either dead or has won
    if (player.isDead())
    {
        std::cout &lt;&lt; "You died at level " &lt;&lt; player.getLevel() &lt;&lt; " and with " &lt;&lt; player.getGold() &lt;&lt; " gold.\n";
        std::cout &lt;&lt; "Too bad you can't take it with you!\n";
    }
    else
    {
        std::cout &lt;&lt; "You won the game with " &lt;&lt; player.getGold() &lt;&lt; " gold!\n";
    }

  return 0;
}</code></pre>
                                                       </div>
                                                      </p>
                                                     </p>
                                                    </p>
                                                   </p>
                                                  </p>
                                                 </p>
                                                </p>
                                               </p>
                                              </p>
                                             </p>
                                            </p>
                                           </p>
                                          </p>
                                         </p>
                                        </p>
                                       </p>
                                      </p>
                                     </p>
                                    </p>
                                   </p>
                                  </p>
                                 </p>
                                </p>
                               </p>
                              </p>
                             </p>
                            </p>
                           </p>
                          </p>
                         </p>
                        </p>
                       </p>
                      </p>
                     </p>
                    </p>
                   </p>
                  </p>
                 </p>
                </p>
               </div>
              </p>
             </p>
            </p>
           </p>
          </p>
         </p>
        </p>
       </p>
      </p>
     </p>
    </p>
   </p>
  </p>
 </div>
</div>
