<div class="article-inner">
 <header>
  <div class="entry-meta beforetitle-meta">
  </div>
  <!-- .entry-meta -->
  <h1 class="entry-title singular-title" itemprop="headline">
   8.8 — Introduction to loops and while statements
  </h1>
  <div class="entry-meta aftertitle-meta">
  </div>
  <!-- .entry-meta -->
 </header>
 <div class="entry-content" itemprop="articleBody">
  <p class="cpp-section">
   Introduction to loops
  </p>
  <p>
   And now the real fun begins -- in the next set of lessons, we’ll cover loops.  Loops are control flow constructs that allow a piece of code to execute repeatedly until some condition is met.  Loops add a significant amount of flexibility into your programming toolkit, allowing you to do many things that would otherwise be difficult.
  </p>
  <p>
   For example, let’s say you wanted to print all the numbers between 1 and 10.  Without loops, you might try something like this:
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; "1 2 3 4 5 6 7 8 9 10";
    std::cout &lt;&lt; " done!\n";
    return 0;
}</code></pre>
  <p>
   While that’s doable, it becomes increasingly less so as you want to print more numbers: what if you wanted to print all the numbers between 1 and 1000?  That would be quite a bit of typing!  But such a program is writable in this way because we know at compile time how many numbers we want to print.
  </p>
  <p>
   Now, let’s change the parameters a bit.  What if we wanted to ask the user to enter a number and then print all the numbers between 1 and the number the user entered?  The number the user will enter isn’t knowable at compile-time.  So how might we go about solving this?
  </p>
  <p class="cpp-section cpp-topline" style="clear: both">
   While statements
  </p>
  <p>
   The
   <strong>
    while statement
   </strong>
   (also called a
   <strong>
    while loop
   </strong>
   ) is the simplest of the three loop types that C++ provides, and it has a definition very similar to that of an if-statement:
  </p>
  <pre>while (condition)
    statement;
</pre>
  <p>
   A
   <code>
    while statement
   </code>
   is declared using the
   <strong>
    while
   </strong>
   keyword.  When a while-statement is executed, the expression
   <em>
    condition
   </em>
   is evaluated.  If the condition evaluates to
   <code>
    true
   </code>
   , the associated
   <em>
    statement
   </em>
   executes.
  </p>
  <p>
   However, unlike an if-statement, once the statement has finished executing, control returns to the top of the while-statement and the process is repeated.  This means a while-statement will keep looping as long as the condition continues to evaluate to
   <code>
    true
   </code>
   .
  </p>
  <p>
   Let’s take a look at a simple while loop that prints all the numbers from 1 to 10:
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    int count{ 1 };
    while (count &lt;= 10)
    {
        std::cout &lt;&lt; count &lt;&lt; ' ';
        ++count;
    }

    std::cout &lt;&lt; "done!\n";

    return 0;
}</code></pre>
  <p>
   This outputs:
  </p>
  <pre>1 2 3 4 5 6 7 8 9 10 done!
</pre>
  <p>
   Let’s take a closer look at what this program is doing.
  </p>
  <p>
   First, we define a variable named
   <code>
    count
   </code>
   and set it to
   <code>
    1
   </code>
   .  The condition
   <code>
    count &lt;= 10
   </code>
   is
   <code>
    true
   </code>
   , so the statement executes.  In this case, our statement is a block, so all the statements in the block will execute.  The first statement in the block prints
   <code>
    1
   </code>
   and a space, and the second increments
   <code>
    count
   </code>
   to 2.  Control now returns back to the top of the while-statement, and the condition is evaluated again.
   <code>
    2 &lt;= 10
   </code>
   evaluates to
   <code>
    true
   </code>
   , so the code block is executed again.  The loop will repeatedly execute until
   <code>
    count
   </code>
   is
   <code>
    11
   </code>
   , at which point
   <code>
    11 &lt;= 10
   </code>
   will evaluate to
   <code>
    false
   </code>
   , and the statement associated with the loop will be skipped.  At this point, the loop is done.
  </p>
  <p>
   While this program is a bit more code than typing all the numbers between 1 and 10, consider how easy it would be to modify the program to print all the numbers between 1 and 1000: all you’d need to do is change
   <code>
    count &lt;= 10
   </code>
   to
   <code>
    count &lt;= 1000
   </code>
   .
  </p>
  <p class="cpp-section cpp-topline" style="clear: both">
   While-statements that evaluate to false initially
  </p>
  <p>
   Note that if the condition initially evaluates to
   <code>
    false
   </code>
   , the associated statement will not execute at all.  Consider the following program:
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    int count{ 15 };
    while (count &lt;= 10)
    {
        std::cout &lt;&lt; count &lt;&lt; ' ';
        ++count;
    }

    std::cout &lt;&lt; "done!\n";

    return 0;
}</code></pre>
  <p>
   The condition
   <code>
    15 &lt;= 10
   </code>
   evaluates to
   <code>
    false
   </code>
   , so the associated statement is skipped.  The program continues, and the only thing printed is
   <code>
    done!
   </code>
   .
  </p>
  <p class="cpp-section cpp-topline" style="clear: both">
   Infinite loops
  </p>
  <p>
   On the other hand, if the expression always evaluates to
   <code>
    true
   </code>
   , the while loop will execute forever.  This is called an
   <strong>
    infinite loop
   </strong>
   .  Here is an example of an infinite loop:
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    int count{ 1 };
    while (count &lt;= 10) // this condition will never be false
    {
        std::cout &lt;&lt; count &lt;&lt; ' '; // so this line will repeatedly execute
    }

    std::cout &lt;&lt; '\n'; // this line will never execute

    return 0; // this line will never execute
}</code></pre>
  <p>
   Because
   <code>
    count
   </code>
   is never incremented in this program,
   <code>
    count &lt;= 10
   </code>
   will always be true.  Consequently, the loop will never terminate, and the program will print
   <code>
    1 1 1 1 1
   </code>
   … forever.
  </p>
  <p class="cpp-section cpp-topline" style="clear: both">
   Intentional infinite loops
  </p>
  <p>
   We can declare an intentional infinite loop like this:
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">while (true)
{
  // this loop will execute forever
}</code></pre>
  <p>
   The only way to exit an infinite loop is through a return-statement, a break-statement, an exit-statement, a goto-statement, an exception being thrown, or the user killing the program.
  </p>
  <p>
   Here’s a silly example demonstrating this:
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{

    while (true) // infinite loop
    {
        std::cout &lt;&lt; "Loop again (y/n)? ";
        char c{};
        std::cin &gt;&gt; c;

        if (c == 'n')
            return 0;
    }

    return 0;
}</code></pre>
  <p>
   This program will continuously loop until the user enters
   <code>
    n
   </code>
   as input, at which point the if-statement will evaluate to
   <code>
    true
   </code>
   and the associated
   <code>
    return 0;
   </code>
   will cause function
   <code>
    main()
   </code>
   to exit, terminating the program.
  </p>
  <p>
   It is common to see this kind of loop in web server applications that run continuously and service web requests.
  </p>
  <div class="cpp-note cpp-lightgreenbackground">
   <p class="cpp-note-title cpp-bottomline">
    Best practice
   </p>
   <p>
    Favor
    <code>
     while(true)
    </code>
    for intentional infinite loops.
   </p>
  </div>
  <p class="cpp-section cpp-topline" style="clear: both">
   Loop variables and naming
  </p>
  <p>
   A
   <strong>
    loop variable
   </strong>
   is a variable that is used to control how many times a loop executes.  For example, given
   <code>
    while (count &lt;= 10)
   </code>
   ,
   <code>
    count
   </code>
   is a loop variable.  While most loop variables have type
   <code>
    int
   </code>
   , you will occasionally see other types (e.g.
   <code>
    char
   </code>
   ).
  </p>
  <p>
   Loop variables are often given simple names, with
   <code>
    i
   </code>
   ,
   <code>
    j
   </code>
   , and
   <code>
    k
   </code>
   being the most common.
  </p>
  <div class="cpp-note cpp-lightgraybackground">
   <p class="cpp-note-title cpp-bottomline">
    As an aside…
   </p>
   <p>
    The use of
    <code>
     i
    </code>
    ,
    <code>
     j
    </code>
    , and
    <code>
     k
    </code>
    for loop variable names arose because these are the first three shortest names for integral variables in the Fortran programming language.  The convention has persisted since.
   </p>
  </div>
  <p>
   However, if you want to know where in your program a loop variable is used, and you use the search function on
   <code>
    i
   </code>
   ,
   <code>
    j
   </code>
   , or
   <code>
    k
   </code>
   , the search function will return half of the lines in your program!  For this reason, some developers prefer loop variable names like
   <code>
    iii
   </code>
   ,
   <code>
    jjj
   </code>
   , or
   <code>
    kkk
   </code>
   .  Because these names are more unique, this makes searching for loop variables much easier, and helps them stand out as loop variables.  An even better idea is to use “real” variable names, such as
   <code>
    count
   </code>
   ,
   <code>
    index
   </code>
   , or a name that gives more detail about what you’re counting (e.g.
   <code>
    userCount
   </code>
   ).
  </p>
  <p>
   The most common type of loop variable is called a
   <strong>
    counter
   </strong>
   , which is a loop variable that counts how many times a loop has executed.  In the examples above, the variable
   <code>
    count
   </code>
   is a counter.
  </p>
  <p class="cpp-section cpp-topline" style="clear: both">
   Integral loop variables should be signed
  </p>
  <p>
   Integral loop variables should almost always be signed, as unsigned integers can lead to unexpected issues.  Consider the following code:
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    unsigned int count{ 10 }; // note: unsigned

    // count from 10 down to 0
    while (count &gt;= 0)
    {
        if (count == 0)
        {
            std::cout &lt;&lt; "blastoff!";
        }
        else
        {
            std::cout &lt;&lt; count &lt;&lt; ' ';
        }
        --count;
    }

    std::cout &lt;&lt; '\n';

    return 0;
}</code></pre>
  <p>
   Take a look at the above example and see if you can spot the error.  It’s not very obvious if you haven’t seen this before.
  </p>
  <p>
   It turns out, this program is an infinite loop.  It starts out by printing
   <code>
    10 9 8 7 6 5 4 3 2 1 blastoff!
   </code>
   as desired, but then loop variable
   <code>
    count
   </code>
   overflows, and starts counting down from
   <code>
    4294967295
   </code>
   (assuming 32-bit integers).  Why?  Because the loop condition
   <code>
    count &gt;= 0
   </code>
   will never be false!  When count is
   <code>
    0
   </code>
   ,
   <code>
    0 &gt;= 0
   </code>
   is true.  Then
   <code>
    --count
   </code>
   is executed, and count wraps around back to
   <code>
    4294967295
   </code>
   .  And since
   <code>
    4294967295 &gt;= 0
   </code>
   is
   <code>
    true
   </code>
   , the program continues.  Because
   <code>
    count
   </code>
   is unsigned, it can never be negative, and because it can never be negative, the loop won’t terminate.
  </p>
  <div class="cpp-note cpp-lightgreenbackground">
   <p class="cpp-note-title cpp-bottomline">
    Best practice
   </p>
   <p>
    Integral loop variables should generally be a signed integral type.
   </p>
  </div>
  <p class="cpp-section cpp-topline" style="clear: both">
   Doing something every N iterations
  </p>
  <p>
   Each time a loop executes, it is called an
   <strong>
    iteration
   </strong>
   .
  </p>
  <p>
   Often, we want to do something every 2nd, 3rd, or 4th iteration, such as print a newline.  This can easily be done by using the remainder operator on our counter:
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

// Iterate through every number between 1 and 50
int main()
{
    int count{ 1 };
    while (count &lt;= 50)
    {
        // print the number (pad numbers under 10 with a leading 0 for formatting purposes)
        if (count &lt; 10)
        {
            std::cout &lt;&lt; '0';
        }

        std::cout &lt;&lt; count &lt;&lt; ' ';

        // if the loop variable is divisible by 10, print a newline
        if (count % 10 == 0)
        {
            std::cout &lt;&lt; '\n';
        }
            
        // increment the loop counter
        ++count;
    }

    return 0;
}</code></pre>
  <p>
   This program produces the result:
  </p>
  <pre>01 02 03 04 05 06 07 08 09 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30
31 32 33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48 49 50
</pre>
  <p class="cpp-section cpp-topline" style="clear: both">
   Nested loops
  </p>
  <p>
   It is also possible to nest loops inside of other loops.  Nested loops tend to be a bit confusing to new programmers, so let’s start with a slightly easier example:
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

void printUpto(int outer)
{
    // loop between 1 and outer
    // note: inner will be created and destroyed at the end of the block
    int inner{ 1 };
    while (inner &lt;= outer)
    {
        std::cout &lt;&lt; inner &lt;&lt; ' ';
        ++inner;
    }
} // inner destroyed here

int main()
{
    // outer loops between 1 and 5
    int outer{ 1 };
    while (outer &lt;= 5)
    {
        // For each iteration of the outer loop, the code in the body of the loop executes once

        // This function prints numbers between 1 and outer
        printUpto(outer);

        // print a newline at the end of each row
        std::cout &lt;&lt; '\n';
        ++outer;
    }

    return 0;
}</code></pre>
  <p>
   In this example, we have an outer loop with a counter named
   <code>
    outer
   </code>
   that counts from 1 to 5.  For each iteration of the loop, the body of the loop calls
   <code>
    printUpto()
   </code>
   using the outer loop variable as an argument, prints a newline, and increments
   <code>
    outer
   </code>
   .  The
   <code>
    printUpto()
   </code>
   function also has a loop which prints all the numbers between 1 and the value passed in.
  </p>
  <p>
   Therefore, when
   <code>
    outer
   </code>
   is 1, the loop body calls
   <code>
    printUpto(1)
   </code>
   , which prints the number
   <code>
    1
   </code>
   .  The loop body then prints a newline and increments
   <code>
    outer
   </code>
   .  Now
   <code>
    outer
   </code>
   is 2.  The loop body executes again, calling
   <code>
    printUpto(2)
   </code>
   , which prints
   <code>
    1 2
   </code>
   .  The loop body prints another newline and increments
   <code>
    outer
   </code>
   .  Successive iterations call
   <code>
    printUpto(3)
   </code>
   ,
   <code>
    printUpto(4)
   </code>
   , and
   <code>
    printUpto(5)
   </code>
   .
  </p>
  <p>
   Therefore, this program prints:
  </p>
  <pre>1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
</pre>
  <p>
   Note that this is a form of a nested loop -- in the body of the outer loop, we’re calling a function that has a loop itself.  In other words, for each iteration of the outer loop, the loop in the function executes.
  </p>
  <p>
   Now let’s move to the more confusing example:
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    // outer loops between 1 and 5
    int outer{ 1 };
    while (outer &lt;= 5)
    {
        // For each iteration of the outer loop, the code in the body of the loop executes once

        // inner loops between 1 and outer
        // note: inner will be created and destroyed at the end of the block
        int inner{ 1 };
        while (inner &lt;= outer)
        {
            std::cout &lt;&lt; inner &lt;&lt; ' ';
            ++inner;
        }

        // print a newline at the end of each row
        std::cout &lt;&lt; '\n';
        ++outer;
    } // inner destroyed here

    return 0;
}</code></pre>
  <p>
   This program has the exact same output:
  </p>
  <pre>1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
</pre>
  <p>
   Because we have a while-loop nested directly within another while-loop, this looks a bit more confusing.  However, all we’ve done is put the code that used to be inside the
   <code>
    printUpto()
   </code>
   function directly inside the outer loop body.
  </p>
  <p>
   Let’s examine how this works in more detail.
  </p>
  <p>
   First, we have an outer loop (with loop variable
   <code>
    outer
   </code>
   ) that will loop 5 times (with
   <code>
    outer
   </code>
   having values
   <code>
    1
   </code>
   ,
   <code>
    2
   </code>
   ,
   <code>
    3
   </code>
   ,
   <code>
    4
   </code>
   , and
   <code>
    5
   </code>
   successively).
  </p>
  <p>
   On the first iteration of the outer loop,
   <code>
    outer
   </code>
   has value
   <code>
    1
   </code>
   , and then the outer loop body executes.  Inside the body of the outer loop, we have another loop with loop variable
   <code>
    inner
   </code>
   .  The inner loop iterates from
   <code>
    1
   </code>
   to
   <code>
    outer
   </code>
   (which has value
   <code>
    1
   </code>
   ), so this inner loop will execute once, printing the value
   <code>
    1
   </code>
   .  Then we print a newline, and increment
   <code>
    outer
   </code>
   to
   <code>
    2
   </code>
   .
  </p>
  <p>
   On the second iteration of the outer loop,
   <code>
    outer
   </code>
   has value
   <code>
    2
   </code>
   , and then the outer loop body executes.  Inside the body of the outer loop,
   <code>
    inner
   </code>
   again iterates from
   <code>
    1
   </code>
   to
   <code>
    outer
   </code>
   (which now has value
   <code>
    2
   </code>
   ), so this inner loop will execute twice, printing the values
   <code>
    1
   </code>
   and
   <code>
    2
   </code>
   .  Then we print a newline, and increment
   <code>
    outer
   </code>
   to
   <code>
    3
   </code>
   .
  </p>
  <p>
   This process continues, with the inner loop printing
   <code>
    1 2 3
   </code>
   ,
   <code>
    1 2 3 4
   </code>
   , and
   <code>
    1 2 3 4 5
   </code>
   on successive passes.  Eventually,
   <code>
    outer
   </code>
   is incremented to
   <code>
    6
   </code>
   , and because the outer loop condition (
   <code>
    outer &lt;= 5
   </code>
   ) is then false, the outer loop is finished.  Then the program ends.
  </p>
  <p>
   If you’re still finding this confusing, stepping through this program in a debugger line-by-line and watching the values of
   <code>
    inner
   </code>
   and
   <code>
    outer
   </code>
   is a good way to get a better understanding of what’s happening.
  </p>
  <p class="cpp-section cpp-topline" style="clear: both">
   Quiz time
  </p>
  <div class="quiz" style="clear: both">
   <p class="quiz-header">
    Question #1
   </p>
   <p>
    In the above program, why is variable
    <code>
     inner
    </code>
    declared inside the while block instead of immediately following the declaration of
    <code>
     outer
    </code>
    ?
   </p>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_0" style="display:none">
    <p>
     Variable inner is declared inside the while block so that it is recreated (and reinitialized to 1) each time the outer loop executes.  If variable inner were declared before the outer while loop, its value would never be reset to 1, or we’d have to do it with an assignment statement.  Furthermore, because variable inner is only used inside the outer while loop block, it makes sense to declare it there.  Remember, declare your variables in the smallest scope possible!
    </p>
   </div>
   <p>
   </p>
  </div>
  <div class="quiz" style="clear: both">
   <p class="quiz-header">
    Question #2
   </p>
   <p>
    Write a program that prints out the letters a through z along with their ASCII codes.  Use a loop variable of type
    <code>
     char
    </code>
    .
   </p>
   <p>
    <a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')">
     Show Hint
    </a>
   </p>
   <div class="wphint" id="cpp_hint_id_0" style="display:none; margin-bottom: 1em">
    Hint: To print characters as integers, you have to use a static_cast.
   </div>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_1" style="display:none">
    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    char myChar{ 'a' };
    while (myChar &lt;= 'z')
    {
        std::cout &lt;&lt; myChar &lt;&lt; ' ' &lt;&lt; static_cast&lt;int&gt;(myChar) &lt;&lt; '\n';
        ++myChar;
    }

    return 0;
}</code></pre>
   </div>
  </div>
  <div class="quiz" style="clear: both">
   <p class="quiz-header">
    Question #3
   </p>
   <p>
    Invert the nested loops example so it prints the following:
   </p>
   <pre>5 4 3 2 1
4 3 2 1
3 2 1
2 1
1
</pre>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_2" style="display:none">
    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

// Loop between 5 and 1
int main()
{
	int outer{ 5 };
	while (outer &gt;= 1)
	{
		// loop between outer and 1
		int inner{ outer };
		while (inner &gt;= 1)
        {
			std::cout &lt;&lt; inner-- &lt;&lt; ' ';
        }

		// print a newline at the end of each row
		std::cout &lt;&lt; '\n';
		--outer;
	}

	return 0;
}</code></pre>
   </div>
  </div>
  <div class="quiz" style="clear: both">
   <p class="quiz-header">
    Question #4
   </p>
   <p>
    Now make the numbers print like this:
   </p>
   <pre>        1
      2 1
    3 2 1
  4 3 2 1
5 4 3 2 1
</pre>
   <p>
    Hint: Figure out how to make it print like this first:
   </p>
   <pre>X X X X 1
X X X 2 1
X X 3 2 1
X 4 3 2 1
5 4 3 2 1
</pre>
   <p>
    <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')">
     Show Solution
    </a>
   </p>
   <div class="wpsolution" id="cpp_solution_id_3" style="display:none">
    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">// Thanks to Shiva for this solution
#include &lt;iostream&gt;

int main()
{
	// There are 5 rows, we can loop from 1 to 5
	int outer{ 1 };

	while (outer &lt;= 5)
	{
		// Row elements appear in descending order, so start from 5 and loop through to 1
		int inner{ 5 };

		while (inner &gt;= 1)
		{
			// The first number in any row is the same as the row number
			// So number should be printed only if it is &lt;= the row number, space otherwise
			if (inner &lt;= outer)
				std::cout &lt;&lt; inner &lt;&lt; ' '; // print the number and a single space
			else
				std::cout &lt;&lt; "  "; // don't print a number, but print two spaces

			--inner;
		}

		// A row has been printed, move to the next row
		std::cout &lt;&lt; '\n';

		++outer;
	}

	return 0;
}</code></pre>
   </div>
  </div>
  <!-- AI CONTENT END 1 -->
 </div>
 <!-- .entry-content -->
 <!-- .entry-utility -->
</div>
