<div class="article-inner">
 <header>
  <div class="entry-meta beforetitle-meta">
  </div>
  <!-- .entry-meta -->
  <h1 class="entry-title singular-title" itemprop="headline">
   8.x — Chapter 8 summary and quiz
  </h1>
  <div class="entry-meta aftertitle-meta">
  </div>
  <!-- .entry-meta -->
 </header>
 <div class="entry-content" itemprop="articleBody">
  <p class="cpp-section">
   Chapter Review
  </p>
  <p>
   The specific sequence of statements that the CPU executes in a program is called the program’s
   <strong>
    execution path
   </strong>
   .  A
   <strong>
    straight-line program
   </strong>
   takes the same path every time it is run.
  </p>
  <p>
   <strong>
    Control flow statements
   </strong>
   (also called
   <strong>
    Flow control statements
   </strong>
   ) allow the programmer to change the normal path of execution.  When a control flow statement causes the program to begin executing some non-sequential instruction sequence, this is called a
   <strong>
    branch
   </strong>
   .
  </p>
  <p>
   A
   <strong>
    conditional statement
   </strong>
   is a statement that specifies whether some associated statement(s) should be executed or not.
  </p>
  <p>
   <strong>
    If statements
   </strong>
   allow us to execute an associated statement based on whether some condition is
   <code>
    true
   </code>
   .
   <strong>
    Else statements
   </strong>
   execute if the associated condition is
   <code>
    false
   </code>
   .  You can chain together multiple if and else statements.
  </p>
  <p>
   A
   <strong>
    dangling else
   </strong>
   occurs when it is ambiguous which
   <code>
    if statement
   </code>
   an
   <code>
    else statement
   </code>
   is connected to.
   <code>
    Dangling else
   </code>
   statements are matched up with the last unmatched
   <code>
    if statement
   </code>
   in the same block.  Thus, we trivially avoid
   <code>
    dangling else
   </code>
   statements by ensuring the body of an
   <code>
    if statement
   </code>
   is placed in a block.
  </p>
  <p>
   A
   <strong>
    null statement
   </strong>
   is a statement that consists of just a semicolon.  It does nothing, and is used when the language requires a statement to exist but the programmer does not need the statement to do anything.
  </p>
  <p>
   <strong>
    Switch statements
   </strong>
   provide a cleaner and faster method for selecting between a number of matching items.  Switch statements only work with integral types.
   <strong>
    Case labels
   </strong>
   are used to identify the values for the evaluated condition to match.  The statements beneath a
   <strong>
    default label
   </strong>
   are executed if no matching case label can be found.
  </p>
  <p>
   When execution flows from a statement underneath a label into statements underneath a subsequent label, this is called
   <strong>
    fallthrough
   </strong>
   .  A
   <code>
    break statement
   </code>
   (or
   <code>
    return statement
   </code>
   ) can be used to prevent fallthrough. The [[fallthrough]] attribute can be used to document intentional fallthrough.
  </p>
  <p>
   <strong>
    Goto statements
   </strong>
   allow the program to jump to somewhere else in the code, either forward or backwards.  These should generally be avoided, as they can create
   <strong>
    spaghetti code
   </strong>
   , which occurs when a program has a path of execution that resembles a bowl of spaghetti.
  </p>
  <p>
   <strong>
    While loops
   </strong>
   allow the program to loop as long as a given condition evaluates to
   <code>
    true
   </code>
   .  The condition is evaluated before the loop executes.
  </p>
  <p>
   An
   <strong>
    infinite loop
   </strong>
   is a loop that has a condition that always evaluates to
   <code>
    true
   </code>
   .  These loops will loop forever unless another control flow statement is used to stop them.
  </p>
  <p>
   A
   <strong>
    loop variable
   </strong>
   (also called a
   <strong>
    counter
   </strong>
   ) is an integer variable used to count how many times a loop has executed.  Each execution of a loop is called an
   <strong>
    iteration
   </strong>
   .
  </p>
  <p>
   <strong>
    Do while loops
   </strong>
   are similar to while loops, but the condition is evaluated after the loop executes instead of before.
  </p>
  <p>
   <strong>
    For loops
   </strong>
   are the most used loop, and are ideal when you need to loop a specific number of times.  An
   <strong>
    off-by-one error
   </strong>
   occurs when the loop iterates one too many or one too few times.
  </p>
  <p>
   <strong>
    Break statements
   </strong>
   allow us to break out of a switch, while, do while, or for loop (also
   <code>
    range-based for loops
   </code>
   , which we haven’t covered yet).
   <strong>
    Continue statements
   </strong>
   allow us to move immediately to the next loop iteration.
  </p>
  <p>
   <strong>
    Halts
   </strong>
   allow us to terminate our program.
   <strong>
    Normal termination
   </strong>
   means the program has exited in an expected way (and the
   <code>
    status code
   </code>
   will indicate whether it succeeded or not).
   <strong>
    std::exit()
   </strong>
   is automatically called at the end of
   <code>
    main
   </code>
   , or it can be called explicitly to terminate the program.  It does some cleanup, but does not cleanup any local variables, or unwind the call stack.
  </p>
  <p>
   <strong>
    Abnormal termination
   </strong>
   occurs when the program encountered some kind of unexpected error and had to be shut down.
   <strong>
    std::abort
   </strong>
   can be called for an abnormal termination.
  </p>
  <p>
   An
   <strong>
    algorithm
   </strong>
   is a finite sequence of instructions that can be followed to solve some problem or produce some useful result.  An algorithm is considered to be
   <strong>
    stateful
   </strong>
   if it retains some information across calls.  Conversely, a
   <strong>
    stateless
   </strong>
   algorithm does not store any information (and must be given all the information it needs to work with when it is called).  When applied to algorithms, the term
   <strong>
    state
   </strong>
   refers to the current values held in stateful variables.
  </p>
  <p>
   An algorithm is considered
   <strong>
    deterministic
   </strong>
   if for a given input (the value provided for
   <code>
    start
   </code>
   ) it will always produce the same output sequence.
  </p>
  <p>
   A
   <strong>
    pseudo-random number generator (PRNG)
   </strong>
   is an algorithm that generates a sequence of numbers whose properties simulate a sequence of random numbers.  When a PRNG is instantiated, an initial value (or set of values) called a
   <strong>
    random seed
   </strong>
   (or
   <strong>
    seed
   </strong>
   for short) can be provided to initialize the state of the PRNG.  When a PRNG has been initialized with a seed, we say it has been
   <strong>
    seeded
   </strong>
   .  The size of the seed value can be smaller than the size of the state of the PRNG.  When this happens, we say the PRNG has been
   <strong>
    underseeded
   </strong>
   .  The length of the sequence before a PRNG begins to repeat itself is known as the
   <strong>
    period
   </strong>
   .
  </p>
  <p>
   A
   <strong>
    random number distribution
   </strong>
   converts the output of a PRNG into some other distribution of numbers.  A
   <strong>
    uniform distribution
   </strong>
   is a random number distribution that produces outputs between two numbers X and Y (inclusive) with equal probability.
  </p>
  <p class="cpp-section cpp-topline" style="clear: both">
   Quiz time
  </p>
  <p>
   Warning: The quizzes start getting harder from this point forward, but you can do it.  Let’s rock these quizzes!
  </p>
  <p class="cpp-quiz-question" style="clear: both">
   Question #1
  </p>
  <p>
   In lesson
   <a href="https://www.learncpp.com/cpp-tutorial/chapter-4-summary-and-quiz/">
    4.x -- Chapter 4 summary and quiz
   </a>
   , we wrote a program to simulate a ball falling off of a tower.  Because we didn’t have loops yet, the ball could only fall for 5 seconds.
  </p>
  <p>
   Take the program below and modify it so that the ball falls for as many seconds as needed until it reaches the ground.  Update the program to use all covered best practices (namespaces, constexpr, etc…).
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

// Gets tower height from user and returns it
double getTowerHeight()
{
	std::cout &lt;&lt; "Enter the height of the tower in meters: ";
	double towerHeight{};
	std::cin &gt;&gt; towerHeight;
	return towerHeight;
}

// Returns the current ball height after "seconds" seconds
double calculateBallHeight(double towerHeight, int seconds)
{
	const double gravity { 9.8 };
    
	// Using formula: s = (u * t) + (a * t^2) / 2
	// here u (initial velocity) = 0, so (u * t) = 0
	const double fallDistance { gravity * (seconds * seconds) / 2.0 };
	const double ballHeight { towerHeight - fallDistance };

	// If the ball would be under the ground, place it on the ground
	if (ballHeight &lt; 0.0)
		return 0.0;
    
	return ballHeight;
}

// Prints ball height above ground
void printBallHeight(double ballHeight, int seconds)
{
	if (ballHeight &gt; 0.0)
		std::cout &lt;&lt; "At " &lt;&lt; seconds &lt;&lt; " seconds, the ball is at height: " &lt;&lt; ballHeight &lt;&lt; " meters\n";
	else
		std::cout &lt;&lt; "At " &lt;&lt; seconds &lt;&lt; " seconds, the ball is on the ground.\n";
}

// Calculates the current ball height and then prints it
// This is a helper function to make it easier to do this
void calculateAndPrintBallHeight(double towerHeight, int seconds)
{
	const double ballHeight{ calculateBallHeight(towerHeight, seconds) };
	printBallHeight(ballHeight, seconds);
}

int main()
{
	const double towerHeight{ getTowerHeight() };

	calculateAndPrintBallHeight(towerHeight, 0);
	calculateAndPrintBallHeight(towerHeight, 1);
	calculateAndPrintBallHeight(towerHeight, 2);
	calculateAndPrintBallHeight(towerHeight, 3);
	calculateAndPrintBallHeight(towerHeight, 4);
	calculateAndPrintBallHeight(towerHeight, 5);
       
	return 0;
}</code></pre>
  <p>
   <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')">
    Show Solution
   </a>
  </p>
  <div class="wpsolution" id="cpp_solution_id_0" style="display:none">
   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

namespace Constants
{
	constexpr double gravity { 9.8 };
}

// Gets tower height from user and returns it
double getTowerHeight()
{
	std::cout &lt;&lt; "Enter the height of the tower in meters: ";
	double towerHeight{};
	std::cin &gt;&gt; towerHeight;
	return towerHeight;
}

// Returns the current ball height after "seconds" seconds
constexpr double calculateBallHeight(double towerHeight, int seconds)
{
	// Using formula: s = (u * t) + (a * t^2) / 2
	// here u (initial velocity) = 0, so (u * t) = 0
	const double fallDistance { Constants::gravity * (seconds * seconds) / 2.0 };
	const double ballHeight { towerHeight - fallDistance };

	if (ballHeight &lt; 0.0)
		return 0.0;
    
	return ballHeight;
}

// Prints ball height above ground
void printBallHeight(double ballHeight, int seconds)
{
	if (ballHeight &gt; 0.0)
		std::cout &lt;&lt; "At " &lt;&lt; seconds &lt;&lt; " seconds, the ball is at height: " &lt;&lt; ballHeight &lt;&lt; " meters\n";
	else
		std::cout &lt;&lt; "At " &lt;&lt; seconds &lt;&lt; " seconds, the ball is on the ground.\n";
}

// Calculates the current ball height and then prints it
// This is a helper function to make it easier to do this
double calculateAndPrintBallHeight(double towerHeight, int seconds)
{
	const double ballHeight{ calculateBallHeight(towerHeight, seconds) };
	printBallHeight(ballHeight, seconds);

	return ballHeight;
}

int main()
{
	const double towerHeight{ getTowerHeight() };

	int seconds { 0 };
	while (calculateAndPrintBallHeight(towerHeight, seconds) &gt; 0.0)
	{
		++seconds;
	}
       
	return 0;
}</code></pre>
  </div>
  <p class="cpp-quiz-question cpp-topline" style="clear: both">
   Question #2
  </p>
  <p>
   A prime number is a natural number greater than 1 that is evenly divisible (with no remainder) only by 1 and itself.
  </p>
  <p>
   Complete the following program by writing the
   <code>
    isPrime()
   </code>
   function using a for-loop.  When successful, the program will print “Success!”.
  </p>
  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">// Make sure that assert triggers even if we compile in release mode
#undef NDEBUG

#include &lt;cassert&gt; // for assert
#include &lt;iostream&gt;

bool isPrime(int x)
{
    return false;
    // write this function using a for loop
}

int main()
{
    assert(!isPrime(0)); // terminate program if isPrime(0) is true
    assert(!isPrime(1));
    assert(isPrime(2));  // terminate program if isPrime(2) is false
    assert(isPrime(3));
    assert(!isPrime(4));
    assert(isPrime(5));
    assert(isPrime(7));
    assert(!isPrime(9));
    assert(isPrime(11));
    assert(isPrime(13));
    assert(!isPrime(15));
    assert(!isPrime(16));
    assert(isPrime(17));
    assert(isPrime(19));
    assert(isPrime(97));
    assert(!isPrime(99));
    assert(isPrime(13417));

    std::cout &lt;&lt; "Success!\n";

    return 0;
}</code></pre>
  <div class="cpp-note cpp-lightgraybackground">
   <p class="cpp-note-title cpp-bottomline">
    Related content
   </p>
   <p>
    <code>
     assert
    </code>
    is a preprocessor macro that terminates the program if the associated argument evaluates to false.  So when we write
    <code>
     assert(!isPrime(0))
    </code>
    , we’re meaning “if isPrime(0) is true, then terminate the program”.  We cover assert in more detail in lesson
    <a href="https://www.learncpp.com/cpp-tutorial/assert-and-static_assert/">
     9.6 -- Assert and static_assert
    </a>
    .
   </p>
  </div>
  <p>
   <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')">
    Show Solution
   </a>
  </p>
  <div class="wpsolution" id="cpp_solution_id_1" style="display:none">
   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">// Make sure that assert triggers even if we compile in release mode
#undef NDEBUG

#include &lt;cassert&gt; // for assert
#include &lt;iostream&gt;

// Non-optimized version
bool isPrime(int x)
{
    if (x &lt;= 1) // if x is negative, 0, or 1 then the number is not prime
        return false;

    for (int test{ 2 }; test &lt; x; ++test)
    {
        if (x % test == 0) // if x is evenly divisible
            return false;  // then this number isn't prime
    }

    return true; // if we didn't find any divisors, then x must be prime
}

int main()
{
    assert(!isPrime(0));
    assert(!isPrime(1));
    assert(isPrime(2));
    assert(isPrime(3));
    assert(!isPrime(4));
    assert(isPrime(5));
    assert(isPrime(7));
    assert(!isPrime(9));
    assert(isPrime(11));
    assert(isPrime(13));
    assert(!isPrime(15));
    assert(!isPrime(16));
    assert(isPrime(17));
    assert(isPrime(19));
    assert(isPrime(97));
    assert(!isPrime(99));
    assert(isPrime(13417));

    std::cout &lt;&lt; "Success!\n";

    return 0;
}</code></pre>
  </div>
  <p>
   Extra credit:
  </p>
  <p>
   The for-loop in the above solution is suboptimal for two reasons:
  </p>
  <ul>
   <li>
    It checks even divisors.  We don’t need to test these (except for 2).
   </li>
   <li>
    It checks every number up to
    <code>
     x
    </code>
    to see if it is a divisor.  A non-prime number (a composite number) must have at least one divisor less than or equal to its square root, so checking for divisors beyond the square root of
    <code>
     x
    </code>
    is unnecessary.
    <code>
     std::sqrt(x)
    </code>
    (in the &lt;cmath&gt; header) returns the square root of
    <code>
     x
    </code>
    .
   </li>
  </ul>
  <p>
   For the latter, we have two options: calculate
   <code>
    std::sqrt(x)
   </code>
   prior to the loop, then test our loop variable against that value.  Alternately, we can optimize
   <code>
    std::sqrt(x)
   </code>
   out of the comparison entirely by squaring both sides of the comparison (h/t to reader JJag for suggesting this) (see the hint if you need additional help with this).  We’ll use this latter option in the quiz solution.
  </p>
  <p>
   <a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')">
    Show Hint
   </a>
  </p>
  <div class="wphint" id="cpp_hint_id_0" style="display:none; margin-bottom: 1em">
   Hint: Given two variables
   <code>
    a &gt;= 0
   </code>
   and
   <code>
    b &gt;= 0
   </code>
   , we can square both sides of the comparison
   <code>
    a &lt;= sqrt(b)
   </code>
   and the comparison will still hold.  This gives us
   <code>
    a * a &lt;= sqrt(b) * sqrt(b)
   </code>
   , which is equivalent to
   <code>
    a * a &lt;= b
   </code>
   .
  </div>
  <p>
   Update the above solution to implement both of these optimizations.
  </p>
  <p>
   <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')">
    Show Solution
   </a>
  </p>
  <div class="wpsolution" id="cpp_solution_id_2" style="display:none">
   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;cassert&gt;
#include &lt;cmath&gt; // for std::sqrt
#include &lt;iostream&gt;

// optimized version
bool isPrime(int x)
{
    if (x &lt;= 1)     // if x is negative, 0, or 1 then the number is not prime
        return false;
    if (x == 2)     // the number 2 is the only even prime
        return true;
    if (x % 2 == 0) // any other even number is not prime
        return false;

    // For any number 3 or greater, test odd values (this is why we add 2)
    // between 3 and sqrt(x) to see if they are a divisor
    // Also see https://stackoverflow.com/questions/5811151/why-do-we-check-up-to-the-square-root-of-a-number-to-determine-if-the-number-is
    // Since test &gt;= 0 and x &gt;=0, we can optimize test &lt; std::sqrt(x) to test * text &lt; x
    for (int test{ 3 }; test * test &lt;= x; test += 2)
    {
        if (x % test == 0) // if x is evenly divisible
            return false;  // then this number isn't prime
    }

    return true; // if we didn't find any divisors, then x must be prime
}

int main()
{
    assert(!isPrime(0));
    assert(!isPrime(1));
    assert(isPrime(2));
    assert(isPrime(3));
    assert(!isPrime(4));
    assert(isPrime(5));
    assert(isPrime(7));
    assert(!isPrime(9));
    assert(isPrime(11));
    assert(isPrime(13));
    assert(!isPrime(15));
    assert(!isPrime(16));
    assert(isPrime(17));
    assert(isPrime(19));
    assert(isPrime(97));
    assert(!isPrime(99));
    assert(isPrime(13417));

    std::cout &lt;&lt; "Success!\n";

    return 0;
}</code></pre>
  </div>
  <p class="cpp-quiz-question cpp-topline" style="clear: both">
   Question #3
  </p>
  <p>
   Implement a game of Hi-Lo.  First, your program should pick a random integer between 1 and 100. The user is given 7 tries to guess the number.
  </p>
  <p>
   If the user does not guess the correct number, the program should tell them whether they guessed too high or too low. If the user guesses the right number, the program should tell them they won. If they run out of guesses, the program should tell them they lost, and what the correct number is. At the end of the game, the user should be asked if they want to play again. If the user doesn’t enter ‘y’ or ‘n’, ask them again.
  </p>
  <p>
   For this quiz, assume the user enters a valid number.
  </p>
  <p>
   Use the Random.h header from
   <a href="https://www.learncpp.com/cpp-tutorial/global-random-numbers-random-h/#RandomH">
    8.15 -- Global random numbers (Random.h)
   </a>
   .
  </p>
  <p>
   Here’s what your output should look like:
  </p>
  <pre>Let's play a game. I'm thinking of a number between 1 and 100. You have 7 tries to guess what it is.
Guess #1: 64
Your guess is too high.
Guess #2: 32
Your guess is too low.
Guess #3: 54
Your guess is too high.
Guess #4: 51
Correct! You win!
Would you like to play again (y/n)? y
Let's play a game. I'm thinking of a number between 1 and 100. You have 7 tries to guess what it is.
Guess #1: 64
Your guess is too high.
Guess #2: 32
Your guess is too low.
Guess #3: 54
Your guess is too high.
Guess #4: 51
Your guess is too high.
Guess #5: 36
Your guess is too low.
Guess #6: 45
Your guess is too low.
Guess #7: 48
Your guess is too low.
Sorry, you lose. The correct number was 49.
Would you like to play again (y/n)? q
Would you like to play again (y/n)? n
Thank you for playing.
</pre>
  <p>
   For extra credit: make the minimum and maximum values and the number of guesses a configurable parameter.
  </p>
  <p>
   <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')">
    Show Solution
   </a>
  </p>
  <div class="wpsolution" id="cpp_solution_id_3" style="display:none">
   <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;
#include "Random.h" // https://www.learncpp.com/cpp-tutorial/global-random-numbers-random-h/

// returns true if the user won, false if they lost
bool playHiLo(int guesses, int min, int max)
{
	std::cout &lt;&lt; "Let's play a game. I'm thinking of a number between " &lt;&lt; min &lt;&lt; " and " &lt;&lt; max &lt;&lt; ". You have " &lt;&lt; guesses &lt;&lt; " tries to guess what it is.\n";
	int number{ Random::get(min, max) }; // this is the number the user needs to guess

	// Loop through all of the guesses
	for (int count{ 1 }; count &lt;= guesses; ++count)
	{
		std::cout &lt;&lt; "Guess #" &lt;&lt; count &lt;&lt; ": ";

		int guess{};
		std::cin &gt;&gt; guess;

		if (guess &gt; number)
			std::cout &lt;&lt; "Your guess is too high.\n";
		else if (guess &lt; number)
			std::cout &lt;&lt; "Your guess is too low.\n";
		else // guess == number, so the user won
		{
			std::cout &lt;&lt; "Correct! You win!\n";
			return true;
		}
	}

	// The user lost
	std::cout &lt;&lt; "Sorry, you lose. The correct number was " &lt;&lt; number &lt;&lt; '\n';
	return false;
}

bool playAgain()
{
	// Keep asking the user if they want to play again until they pick y or n.
	while (true)
	{
		char ch{};
		std::cout &lt;&lt; "Would you like to play again (y/n)? ";
		std::cin &gt;&gt; ch;

		switch (ch)
		{
		case 'y': return true;
		case 'n': return false;
		}
	}
}

int main()
{
	constexpr int guesses { 7 }; // the user has this many guesses
	constexpr int min     { 1 };
	constexpr int max     { 100 };

	do
	{
		playHiLo(guesses, min, max);
	} while (playAgain());

	std::cout &lt;&lt; "Thank you for playing.\n";

	return 0;
}</code></pre>
  </div>
  <p>
   We’ll add error handling to this solution in lesson
   <a href="https://www.learncpp.com/cpp-tutorial/chapter-9-summary-and-quiz/">
    9.x -- Chapter 9 summary and quiz
   </a>
   .
  </p>
  <!-- AI CONTENT END 1 -->
 </div>
 <!-- .entry-content -->
 <!-- .entry-utility -->
</div>
