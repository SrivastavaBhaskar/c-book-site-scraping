<div class="article-inner">
 <header>
  <div class="entry-meta beforetitle-meta">
  </div>
  <h1 class="entry-title singular-title" itemprop="headline">
   F.1 — Constexpr functions
  </h1>
  <div class="entry-meta aftertitle-meta">
  </div>
 </header>
 <div class="entry-content" itemprop="articleBody">
  <p>
   In lesson
   <a href="https://www.learncpp.com/cpp-tutorial/constexpr-variables/">
    5.6 -- Constexpr variables
   </a>
   , we introduced the
   <code>
    constexpr
   </code>
   keyword, which we used to create compile-time (symbolic) constants. We also introduced constant expressions, which are expressions that can be evaluated at compile-time rather than runtime.
   <p>
    One challenge with constant expressions is that function call to a normal function are not allowed in constant expressions. This means we cannot use such function calls anywhere a constant expression is required.
    <p>
     Consider the following program:
     <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int main()
{
    constexpr double radius { 3.0 };
    constexpr double pi { 3.14159265359 };
    constexpr double circumference { 2.0 * radius * pi };
    
    std::cout &lt;&lt; "Our circle has circumference " &lt;&lt; circumference &lt;&lt; "\n";

    return 0;    
}</code></pre>
     <p>
      This produces the result:
      <pre>Our circle has circumference 18.8496
</pre>
      <p>
       Having a complex initializer for
       <code>
        circumference
       </code>
       isn’t great (and requires us to instantiate two supporting variables,
       <code>
        radius
       </code>
       and
       <code>
        pi
       </code>
       ). So let’s make it a function instead:
       <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

double calcCircumference(double radius)
{
    constexpr double pi { 3.14159265359 };
    return 2.0 * pi * radius;
}

int main()
{
    constexpr double circumference { calcCircumference(3.0) }; // compile error
    
    std::cout &lt;&lt; "Our circle has circumference " &lt;&lt; circumference &lt;&lt; "\n";

    return 0;    
}</code></pre>
       <p>
        This code is much cleaner. It also doesn’t compile. Constexpr variable
        <code>
         circumference
        </code>
        requires that its initializer is a constant expression, and the call
        <code>
         calcCircumference()
        </code>
        isn’t a constant expression.
        <p>
         In this particular case, we could make
         <code>
          circumference
         </code>
         non-constexpr, and the program would compile. While we’d lose the benefits of constant expressions, at least the program would run.
         <p>
          However, there are other cases in C++ (which we’ll introduce in the future) where we do not have alternate options available, and only a constant expression will do. In those cases, we’d really like to be able to use functions, but calls to normal functions just won’t work. So what are we to do?
          <p class="cpp-section cpp-topline" style="clear:both">
           Constexpr functions can be used in constant expressions
           <p>
            A
            <strong>
             constexpr function
            </strong>
            is a function that is allowed to be called in a constant expression.
            <p>
             To make a function a constexpr function, we simply use the
             <code>
              constexpr
             </code>
             keyword in front of the function’s return type.
             <div class="cpp-note cpp-lightbluebackground">
              <p class="cpp-note-title cpp-bottomline">
               Key insight
               <p>
                The
                <code>
                 constexpr
                </code>
                keyword is used to signal to the compiler and other developers that a function can be used in a constant expression.
               </p>
              </p>
             </div>
             <p>
              Here’s the same example as above, but using a constexpr function:
              <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

constexpr double calcCircumference(double radius) // now a constexpr function
{
    constexpr double pi { 3.14159265359 };
    return 2.0 * pi * radius;
}

int main()
{
    constexpr double circumference { calcCircumference(3.0) }; // now compiles
    
    std::cout &lt;&lt; "Our circle has circumference " &lt;&lt; circumference &lt;&lt; "\n";

    return 0;    
}</code></pre>
              <p>
               Because
               <code>
                calcCircumference()
               </code>
               is now a constexpr function, it can be used in a constant expression, such as the initializer of
               <code>
                circumference
               </code>
               .
               <p class="cpp-section cpp-topline" style="clear:both">
                Constexpr functions can be evaluated at compile time
                <p>
                 In lesson
                 <a href="https://www.learncpp.com/cpp-tutorial/constant-expressions/">
                  5.5 -- Constant expressions
                 </a>
                 , we noted that in contexts that require a constant expression (such as the initialization of a constexpr variable), a constant expression is required to evaluate at compile-time. If a required constant expression contains a constexpr function call, that constexpr function call must evaluate at compile-time.
                 <p>
                  In our example above, variable
                  <code>
                   circumference
                  </code>
                  is constexpr and thus requires a constant expression initializer. Since
                  <code>
                   calcCircumference()
                  </code>
                  is part of this required constant expression,
                  <code>
                   calcCircumference()
                  </code>
                  must be evaluated at compile-time.
                  <p>
                   When a function call is evaluated at compile-time, the compiler will calculate the return value of the function call at compile-time, and then replace the function call with the return value.
                   <p>
                    So in our example, the call to
                    <code>
                     calcCircumference(3.0)
                    </code>
                    is replaced with the result of the function call, which is
                    <code>
                     18.8496
                    </code>
                    . In other words, the compiler will compile this:
                    <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

constexpr double calcCircumference(double radius)
{
    constexpr double pi { 3.14159265359 };
    return 2.0 * pi * radius;
}

int main()
{
    constexpr double circumference { 18.8496 };
    
    std::cout &lt;&lt; "Our circle has circumference " &lt;&lt; circumference &lt;&lt; "\n";

    return 0;    
}</code></pre>
                    <p>
                     To evaluate at compile-time, two other things must also be true:
                     <ul>
                      <li>
                       The call to the constexpr function must have arguments that are known at compile time (e.g. are constant expressions).
                       <li>
                        All statements and expressions within the constexpr function must be evaluatable at compile-time.
                       </li>
                      </li>
                     </ul>
                     <p>
                      When a constexpr (or consteval) function is being evaluated at compile-time, any other functions it calls are required to be evaluated at compile-time (otherwise the initial function would not be able to return a result at compile-time).
                      <div class="cpp-note cpp-lightgraybackground">
                       <p class="cpp-note-title cpp-bottomline">
                        For advanced readers
                        <p>
                         There are some other lesser encountered criteria as well. These can be found
                         <a href="https://en.cppreference.com/w/cpp/language/constexpr">
                          here
                         </a>
                         .
                        </p>
                       </p>
                      </div>
                      <p class="cpp-section cpp-topline" style="clear:both">
                       Constexpr functions can also be evaluated at runtime
                       <p>
                        Constexpr functions can also be evaluated at runtime, in which case they will return a non-constexpr result. For example:
                        <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

constexpr int greater(int x, int y)
{
    return (x &gt; y ? x : y);
}

int main()
{
    int x{ 5 }; // not constexpr
    int y{ 6 }; // not constexpr

    std::cout &lt;&lt; greater(x, y) &lt;&lt; " is greater!\n"; // will be evaluated at runtime

    return 0;
}</code></pre>
                        <p>
                         In this example, because arguments
                         <code>
                          x
                         </code>
                         and
                         <code>
                          y
                         </code>
                         are not constant expressions, the function cannot be resolved at compile-time. However, the function will still be resolved at runtime, returning the expected value as a non-constexpr
                         <code>
                          int
                         </code>
                         .
                         <div class="cpp-note cpp-lightbluebackground">
                          <p class="cpp-note-title cpp-bottomline">
                           Key insight
                           <p>
                            When a constexpr function evaluates at runtime, it evaluates just like a normal (non-constexpr) function would. In other words, the
                            <code>
                             constexpr
                            </code>
                            has no effect in this case.
                           </p>
                          </p>
                         </div>
                         <div class="cpp-note cpp-lightbluebackground">
                          <p class="cpp-note-title cpp-bottomline">
                           Key insight
                           <p>
                            Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases.
                            <p>
                             Otherwise, you’d need to have separate functions (a function with a constexpr return type, and a function with a non-constexpr return type). This would not only require duplicate code, the two functions would also need to have different names!
                            </p>
                           </p>
                          </p>
                         </div>
                         <p class="cpp-section cpp-topline" style="clear:both">
                          Constexpr function calls in non-required constant expressions
                          <p>
                           You might expect that a constexpr function would evaluate at compile-time whenever possible, but unfortunately this is not the case.
                           <p>
                            In lesson
                            <a href="https://www.learncpp.com/cpp-tutorial/constant-expressions/">
                             5.5 -- Constant expressions
                            </a>
                            , we noted that in contexts that do not
                            <em>
                             require
                            </em>
                            a constant expression, the compiler may choose whether to evaluate a constant expression at either compile-time or at runtime. Accordingly, any constexpr function call that is part of a non-required constant expression may be evaluated at either compile-time or runtime.
                            <p>
                             For example:
                             <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

constexpr int getValue(int x)
{
    return x;
}

int main()
{
    int x { getValue(5) }; // may evaluate at runtime or compile-time
    
    return 0;
}</code></pre>
                             <p>
                              In the above example, because
                              <code>
                               getValue()
                              </code>
                              is constexpr, the call
                              <code>
                               getValue(5)
                              </code>
                              is a constant expression. However, because variable
                              <code>
                               x
                              </code>
                              is not constexpr, it does not require a constant expression initializer. So even though we’ve provided a constant expression initializer, the compiler is free to choose whether
                              <code>
                               getValue(5)
                              </code>
                              evaluates at runtime or compile-time.
                              <div class="cpp-note cpp-lightbluebackground">
                               <p class="cpp-note-title cpp-bottomline">
                                Key insight
                                <p>
                                 Compile-time evaluation of constexpr functions is only guaranteed when a constant expression is required.
                                </p>
                               </p>
                              </div>
                              <p class="cpp-section cpp-topline" style="clear:both">
                               Diagnosis of constexpr functions
                               <p>
                                The compiler is
                                <em>
                                 not
                                </em>
                                required to determine whether a constexpr function is evaluatable at compile-time until it is actually evaluated at compile-time. It is fairly easy to write a constexpr function that compiles successfully for runtime use, but then fails to compile when evaluated at compile-time.
                                <p>
                                 As a silly example of this:
                                 <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

int getValue(int x)
{
    return x;
}

// This function can be evaluated at runtime
// When evaluated at compile-time, the function will produce a compilation error
// because the call to getValue(x) cannot be resolved at compile-time
constexpr int foo(int x)
{
    if (x &lt; 0) return 0; // needed prior to adoption of P2448R1 in C++23 (see note below)
    return getValue(x);  // call to non-constexpr function here
}

int main()
{
    int x { foo(5) };           // okay: will evaluate at runtime
    constexpr int y { foo(5) }; // compile error: foo(5) can't evaluate at compile-time

    return 0;
}</code></pre>
                                 <p>
                                  In the above example, when
                                  <code>
                                   foo(5)
                                  </code>
                                  is used as an initializer for non-constexpr variable
                                  <code>
                                   x
                                  </code>
                                  , it will be evaluated at runtime. This works fine, and returns the value
                                  <code>
                                   5
                                  </code>
                                  .
                                  <p>
                                   However, when
                                   <code>
                                    foo(5)
                                   </code>
                                   , is used as an initializer for constexpr variable
                                   <code>
                                    y
                                   </code>
                                   , it must be evaluated at compile-time. At that point, the compiler will determine that the call to
                                   <code>
                                    foo(5)
                                   </code>
                                   can’t be evaluated at compile-time, as
                                   <code>
                                    getValue()
                                   </code>
                                   is not a constexpr function.
                                   <p>
                                    Therefore, when writing a constexpr function, always explicitly test that it compiles when evaluated at compile-time (by calling it in a context where a constant expression is required, such as in the initialization of a constexpr variable).
                                    <div class="cpp-note cpp-lightgreenbackground">
                                     <p class="cpp-note-title cpp-bottomline">
                                      Best practice
                                      <p>
                                       All constexpr functions should be evaluatable at compile-time, as they will be required to do so in contexts that require a constant expression.
                                       <p>
                                        Always test your constexpr functions in a context that requires a constant expression, as the constexpr function may work when evaluated at runtime but fail when evaluated at compile-time.
                                       </p>
                                      </p>
                                     </p>
                                    </div>
                                    <div class="cpp-note cpp-lightgraybackground">
                                     <p class="cpp-note-title cpp-bottomline">
                                      For advanced readers
                                      <p>
                                       Prior to C++23, if no argument values exist that would allow a constexpr function to be evaluated at compile-time, the program is ill-formed (no diagnostic required). Without the line
                                       <code>
                                        if (x &lt; 0) return 0
                                       </code>
                                       , the above example would contain no set of arguments that allow the function to be evaluatable at compile-time, making the program ill-formed. Given that no diagnostic is required, the compiler may not enforce this.
                                       <p>
                                        This requirement was revoked in C++23 (
                                        <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2448r1.html">
                                         P2448R1
                                        </a>
                                        ).
                                       </p>
                                      </p>
                                     </p>
                                    </div>
                                    <p class="cpp-section cpp-topline" style="clear:both">
                                     Constexpr/consteval function parameters are not constexpr
                                     <p>
                                      The parameters of a constexpr function are not implicitly constexpr, nor may they be declared as
                                      <code>
                                       constexpr
                                      </code>
                                      .
                                      <div class="cpp-note cpp-lightbluebackground">
                                       <p class="cpp-note-title cpp-bottomline">
                                        Key insight
                                        <p>
                                         A constexpr function parameter would imply the function could only be called with a constexpr argument. But this is not the case -- constexpr functions can be called with non-constexpr arguments when the function is evaluated at runtime.
                                        </p>
                                       </p>
                                      </div>
                                      <p>
                                       Because such parameters are not constexpr, they cannot be used in constant expressions within the function.
                                       <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">consteval int goo(int c)    // c is not constexpr, and cannot be used in constant expressions
{
    return c;
}

constexpr int foo(int b)    // b is not constexpr, and cannot be used in constant expressions
{
    constexpr int b2 { b }; // compile error: constexpr variable requires constant expression initializer

    return goo(b);          // compile error: consteval function call requires constant expression argument
}

int main()
{
    constexpr int a { 5 };

    std::cout &lt;&lt; foo(a); // okay: constant expression a can be used as argument to constexpr function foo()
    
    return 0;
}</code></pre>
                                       <p>
                                        In the above example, function parameter
                                        <code>
                                         b
                                        </code>
                                        is not constexpr (even though argument
                                        <code>
                                         a
                                        </code>
                                        is a constant expression). This means
                                        <code>
                                         b
                                        </code>
                                        cannot be used anywhere a constant expression is required, such as the the initializer for a constexpr variable (e.g.
                                        <code>
                                         b2
                                        </code>
                                        ) or in a call to a consteval function (
                                        <code>
                                         goo(b)
                                        </code>
                                        ).
                                        <p>
                                         The parameters of constexpr functions may be declared as
                                         <code>
                                          const
                                         </code>
                                         , in which case they are treated as runtime constants.
                                         <div class="cpp-note cpp-lightgraybackground">
                                          <p class="cpp-note-title cpp-bottomline">
                                           Related content
                                           <p>
                                            If you need parameters that are constant expressions, see
                                            <a href="https://www.learncpp.com/cpp-tutorial/non-type-template-parameters/">
                                             11.9 -- Non-type template parameters
                                            </a>
                                            .
                                           </p>
                                          </p>
                                         </div>
                                         <p class="cpp-section cpp-topline" style="clear:both">
                                          Constexpr functions are implicitly inline
                                          <p>
                                           When a constexpr function is evaluated at compile-time, the compiler must be able to see the full definition of the constexpr function prior to such function calls (so it can perform the evaluation itself). A forward declaration will not suffice in this case, even if the actual function definition appears later in the same compilation unit.
                                           <p>
                                            This means that a constexpr function called in multiple files needs to have its definition included into each translation unit -- which would normally be a violation of the one-definition rule. To avoid such problems, constexpr functions are implicitly inline, which makes them exempt from the one-definition rule.
                                            <p>
                                             As a result, constexpr functions are often defined in header files, so they can be #included into any .cpp file that requires the full definition.
                                             <div class="cpp-note cpp-lightpurplebackground">
                                              <p class="cpp-note-title cpp-bottomline">
                                               Rule
                                               <p>
                                                The compiler must be able to see the full definition of a constexpr (or consteval) function, not just a forward declaration.
                                               </p>
                                              </p>
                                             </div>
                                             <div class="cpp-note cpp-lightgreenbackground">
                                              <p class="cpp-note-title cpp-bottomline">
                                               Best practice
                                               <p>
                                                Constexpr/consteval functions used in a single source file (.cpp) should be defined in the source file above where they are used.
                                                <p>
                                                 Constexpr/consteval functions used in multiple source files should be defined in a header file so they can be included into each source file.
                                                </p>
                                               </p>
                                              </p>
                                             </div>
                                             <p>
                                              For constexpr function calls that are only evaluated at runtime, a forward declaration is sufficient to satisfy the compiler. This means you can use a forward declaration to call a constexpr function defined in another translation unit, but only if you invoke it in a context that does not require compile-time evaluation.
                                              <div class="cpp-note cpp-lightgraybackground">
                                               <p class="cpp-note-title cpp-bottomline">
                                                For advanced readers
                                                <p>
                                                 Per
                                                 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2166">
                                                  CWG2166
                                                 </a>
                                                 , the actual requirement for the forward declaration of constexpr functions that are evaluated at compile-time is that “the constexpr function must be defined prior to the outermost evaluation that eventually results in the invocation”. Therefore, this is allowed:
                                                 <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

constexpr int foo(int);

constexpr int goo(int c)
{
	return foo(c);   // note that foo is not defined yet
}

constexpr int foo(int b) // okay because foo is still defined before any calls to goo
{
	return b;
}

int main()
{
	 constexpr int a{ goo(5) }; // this is the outermost invocation

	return 0;
}</code></pre>
                                                 <p>
                                                  The intent here is to allow for mutually recursive constexpr functions (where two constexpr functions call each other), which would not be possible otherwise.
                                                 </p>
                                                </p>
                                               </p>
                                              </div>
                                              <p class="cpp-section cpp-topline" style="clear:both">
                                               Recap
                                               <p>
                                                Marking a function as
                                                <code>
                                                 constexpr
                                                </code>
                                                means it can be used in a constant expression. It does not mean “will evaluate at compile-time”.
                                                <p>
                                                 A constant expression (which may contain constexpr function calls) is only required to evaluate at compile-time in contexts where a constant expression is required.
                                                 <p>
                                                  In contexts that do not require a constant expression, the compiler may choose whether to evaluate a constant expression (which may contain constexpr function calls) at compile-time or at runtime.
                                                  <p>
                                                   A runtime (non-constant) expression (which may contain constexpr function calls or non-constexpr function calls) will evaluate at runtime.
                                                   <div class="cpp-note cpp-lightgraybackground">
                                                    <p class="cpp-note-title cpp-bottomline">
                                                     Author’s note
                                                     <p>
                                                      The sections above this author’s note are the most important things to know about constexpr functions. The rest of this lesson contains information that you should read, but is less important to understand deeply.
                                                     </p>
                                                    </p>
                                                   </div>
                                                   <p class="cpp-section cpp-topline" style="clear:both">
                                                    Another example
                                                    <p>
                                                     Let’s do another examine to explore how a constexpr function is required or likely to evaluate further:
                                                     <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

constexpr int greater(int x, int y)
{
    return (x &gt; y ? x : y);
}

int main()
{
    constexpr int g { greater(5, 6) };              // case 1: always evaluated at compile-time
    std::cout &lt;&lt; g &lt;&lt; " is greater!\n";

    std::cout &lt;&lt; greater(5, 6) &lt;&lt; " is greater!\n"; // case 2: may be evaluated at either runtime or compile-time

    int x{ 5 }; // not constexpr but value is known at compile-time
    std::cout &lt;&lt; greater(x, 6) &lt;&lt; " is greater!\n"; // case 3: likely evaluated at runtime

    std::cin &gt;&gt; x;
    std::cout &lt;&lt; greater(x, 6) &lt;&lt; " is greater!\n"; // case 4: always evaluated at runtime

    return 0;
}</code></pre>
                                                     <p>
                                                      In case 1, we’re calling
                                                      <code>
                                                       greater()
                                                      </code>
                                                      in a context that requires a constant expression. Thus
                                                      <code>
                                                       greater()
                                                      </code>
                                                      must be evaluated at compile-time.
                                                      <p>
                                                       In case 2, the
                                                       <code>
                                                        greater()
                                                       </code>
                                                       function is being called in a context that does not require a constant expression, as output statements must execute at runtime. However, since the arguments are constant expressions, the function is eligible to be evaluated at compile-time. Thus the compiler is free to choose whether this call to
                                                       <code>
                                                        greater()
                                                       </code>
                                                       will be evaluated at compile-time or runtime.
                                                       <p>
                                                        In case 3, we’re calling
                                                        <code>
                                                         greater()
                                                        </code>
                                                        with one argument that is not a constant expression. So this will typically execute at runtime.
                                                        <p>
                                                         However, this argument has a value that is known at compile-time. Under the as-if rule, the compiler could decide to treat the evaluation of
                                                         <code>
                                                          x
                                                         </code>
                                                         as a constant expression, and evaluate this call to
                                                         <code>
                                                          greater()
                                                         </code>
                                                         at compile-time. But more likely, it will evaluate it at runtime.
                                                         <div class="cpp-note cpp-lightgraybackground">
                                                          <p class="cpp-note-title cpp-bottomline">
                                                           Related content
                                                           <p>
                                                            We cover the as-if rule in lesson
                                                            <a href="https://www.learncpp.com/cpp-tutorial/constant-expressions/">
                                                             5.5 -- Constant expressions
                                                            </a>
                                                            .
                                                            <p>
                                                             Note that even non-constexpr functions could be evaluated at compile-time under the as-if rule!
                                                            </p>
                                                           </p>
                                                          </p>
                                                         </div>
                                                         <p>
                                                          In case 4, the value of argument
                                                          <code>
                                                           x
                                                          </code>
                                                          can’t be known at compile-time, so this call to
                                                          <code>
                                                           greater()
                                                          </code>
                                                          will always evaluate at runtime.
                                                          <div class="cpp-note cpp-lightbluebackground">
                                                           <p class="cpp-note-title cpp-bottomline">
                                                            Key insight
                                                            <p>
                                                             Put another way, we can categorize the likelihood that a function will actually be evaluated at compile-time as follows:
                                                             <p>
                                                              Always (required by the standard):
                                                              <ul>
                                                               <li>
                                                                Constexpr function is called where constant expression is required.
                                                                <li>
                                                                 Constexpr function is called from other function being evaluated at compile-time.
                                                                </li>
                                                               </li>
                                                              </ul>
                                                              <p>
                                                               Probably (there’s little reason not to):
                                                               <ul>
                                                                <li>
                                                                 Constexpr function is called where constant expression isn’t required, all arguments are constant expressions.
                                                                </li>
                                                               </ul>
                                                               <p>
                                                                Possibly (if optimized under the as-if rule):
                                                                <ul>
                                                                 <li>
                                                                  Constexpr function is called where constant expression isn’t required, some arguments are not constant expressions but their values are known at compile-time.
                                                                  <li>
                                                                   Non-constexpr function capable of being evaluated at compile-time, all arguments are constant expressions.
                                                                  </li>
                                                                 </li>
                                                                </ul>
                                                                <p>
                                                                 Never (not possible):
                                                                 <ul>
                                                                  <li>
                                                                   Constexpr function is called where constant expression isn’t required, some arguments have values that are not known at compile-time.
                                                                  </li>
                                                                 </ul>
                                                                </p>
                                                               </p>
                                                              </p>
                                                             </p>
                                                            </p>
                                                           </p>
                                                          </div>
                                                          <p>
                                                           Note that your compiler’s optimization level setting may have an impact on whether it decides to evaluate a function at compile-time or runtime. This also means that your compiler may make different choices for debug vs. release builds (as debug builds typically have optimizations turned off).
                                                           <p>
                                                            For example, both gcc and Clang will not compile-time evaluate a constexpr function called where a constant expression isn’t required unless the compiler told to optimize the code (e.g. using the
                                                            <code>
                                                             -O2
                                                            </code>
                                                            compiler option).
                                                            <div class="cpp-note cpp-lightgraybackground">
                                                             <p class="cpp-note-title cpp-bottomline">
                                                              For advanced readers
                                                              <p>
                                                               The compiler might also choose to inline a function call, or even optimize a function call away entirely. Both of these can affect when (or if) the content of the function call are evaluated.
                                                              </p>
                                                             </p>
                                                            </div>
                                                            <p class="cpp-section cpp-topline" style="clear:both">
                                                             Determining if a constexpr function call is evaluating at compile-time or runtime
                                                             <p>
                                                              C++ does not currently provide any reliable mechanisms to do this.
                                                              <p class="cpp-section cpp-topline" style="clear:both">
                                                               What about
                                                               <code>
                                                                std::is_constant_evaluated
                                                               </code>
                                                               or
                                                               <code>
                                                                if consteval
                                                               </code>
                                                               ?
                                                               <p>
                                                                Neither of these capabilities tell you whether a function call is evaluating at compile-time or runtime.
                                                                <p>
                                                                 <code>
                                                                  std::is_constant_evaluated()
                                                                 </code>
                                                                 (defined in the &lt;type_traits&gt; header) returns a
                                                                 <code>
                                                                  bool
                                                                 </code>
                                                                 indicating whether the current function is executing in a constant-evaluated context. A
                                                                 <strong>
                                                                  constant-evaluated context
                                                                 </strong>
                                                                 (also called a
                                                                 <strong>
                                                                  constant context
                                                                 </strong>
                                                                 ) is defined as one in which a constant expression is required (such as the initialization of a constexpr variable). So in cases where the compiler is required to evaluate a constant expression at compile-time
                                                                 <code>
                                                                  std::is_constant_evaluated()
                                                                 </code>
                                                                 will
                                                                 <code>
                                                                  true
                                                                 </code>
                                                                 as expected.
                                                                 <p>
                                                                  This is intended to allow you to do something like this:
                                                                  <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;type_traits&gt; // for std::is_constant_evaluated()

constexpr int someFunction()
{
    if (std::is_constant_evaluated()) // if evaluating in constant context
        doSomething();
    else
        doSomethingElse();
}</code></pre>
                                                                  <p>
                                                                   However, the compiler may also choose to evaluate a constexpr function at compile-time in a context that does not require a constant expression. In such cases,
                                                                   <code>
                                                                    std::is_constant_evaluated()
                                                                   </code>
                                                                   will return
                                                                   <code>
                                                                    false
                                                                   </code>
                                                                   even though the function did evaluate at compile-time. So
                                                                   <code>
                                                                    std::is_constant_evaluated()
                                                                   </code>
                                                                   really means “the compiler is being forced to evaluate this at compile-time”, not “this is evaluating at compile-time”.
                                                                   <div class="cpp-note cpp-lightbluebackground">
                                                                    <p class="cpp-note-title cpp-bottomline">
                                                                     Key insight
                                                                     <p>
                                                                      While this may seem strange, there are several reasons for this:
                                                                      <ol start="1">
                                                                       <li>
                                                                        As
                                                                        <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0595r2.html">
                                                                         the paper that proposed this feature
                                                                        </a>
                                                                        indicates, the standard doesn’t actually make a distinction between “compile time” and “runtime”. Defining behavior involving that distinction would have been a larger change.
                                                                        <li>
                                                                         Optimizations should not change the observable behavior of a program (unless explicitly allowed by the standard). If
                                                                         <code>
                                                                          std::is_constant_evaluated()
                                                                         </code>
                                                                         were to return
                                                                         <code>
                                                                          true
                                                                         </code>
                                                                         when the function was evaluated at compile-time for any reason, then the optimizer deciding to evaluate a function at compile-time instead of runtime could potentially change the observable behavior of the function. As a result, your program might behave very differently depending on what optimization level it was compiled with!
                                                                        </li>
                                                                       </li>
                                                                      </ol>
                                                                      <p>
                                                                       While this could be addressed in various ways, those involve adding additional complexity to the optimizer and/or limiting its ability to optimize certain cases.
                                                                      </p>
                                                                     </p>
                                                                    </p>
                                                                   </div>
                                                                   <p>
                                                                    Introduced in C++23,
                                                                    <code>
                                                                     if consteval
                                                                    </code>
                                                                    is a replacement for
                                                                    <code>
                                                                     if (std::is_constant_evaluated())
                                                                    </code>
                                                                    that provides a nicer syntax and fixes some other issues. However, it evaluates the same way.
                                                                    <p class="cpp-section cpp-topline" style="clear:both">
                                                                     Forcing a constexpr function to be evaluated at compile-time
                                                                     <p>
                                                                      There is no way to tell the compiler that a constexpr function should prefer to evaluate at compile-time whenever it can (e.g. in cases where the return value of a constexpr function is used in a non-constant expression).
                                                                      <p>
                                                                       However, we can force a constexpr function that is eligible to be evaluated at compile-time to actually evaluate at compile-time by ensuring the return value is used where a constant expression is required. This needs to be done on a per-call basis.
                                                                       <p>
                                                                        The most common way to do this is to use the return value to initialize a constexpr variable (this is why we’ve been using variable ‘g’ in prior examples). Unfortunately, this requires introducing a new variable into our program just to ensure compile-time evaluation, which is ugly and reduces code readability.
                                                                        <div class="cpp-note cpp-lightgraybackground">
                                                                         <p class="cpp-note-title cpp-bottomline">
                                                                          For advanced readers
                                                                          <p>
                                                                           There are several hacky ways that people have tried to work around the problem of having to introduce a new constexpr variable each time we want to force compile-time evaluation. See
                                                                           <a href="https://quuxplusone.github.io/blog/2018/08/07/force-constexpr/">
                                                                            here
                                                                           </a>
                                                                           and
                                                                           <a href="https://artificial-mind.net/blog/2020/11/14/cpp17-consteval">
                                                                            here
                                                                           </a>
                                                                           .
                                                                          </p>
                                                                         </p>
                                                                        </div>
                                                                        <p>
                                                                         However, in C++20, there is a better workaround to this issue, which we’ll present in a moment.
                                                                         <p class="cpp-section cpp-topline" style="clear:both">
                                                                          Consteval
                                                                          <p>
                                                                           C++20 introduces the keyword
                                                                           <strong>
                                                                            consteval
                                                                           </strong>
                                                                           , which is used to indicate that a function
                                                                           <em>
                                                                            must
                                                                           </em>
                                                                           evaluate at compile-time, otherwise a compile error will result. Such functions are called
                                                                           <strong>
                                                                            immediate functions
                                                                           </strong>
                                                                           .
                                                                           <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

consteval int greater(int x, int y) // function is now consteval
{
    return (x &gt; y ? x : y);
}

int main()
{
    constexpr int g { greater(5, 6) };              // ok: will evaluate at compile-time
    std::cout &lt;&lt; g &lt;&lt; '\n';

    std::cout &lt;&lt; greater(5, 6) &lt;&lt; " is greater!\n"; // ok: will evaluate at compile-time

    int x{ 5 }; // not constexpr
    std::cout &lt;&lt; greater(x, 6) &lt;&lt; " is greater!\n"; // error: consteval functions must evaluate at compile-time

    return 0;
}</code></pre>
                                                                           <p>
                                                                            In the above example, the first two calls to
                                                                            <code>
                                                                             greater()
                                                                            </code>
                                                                            will evaluate at compile-time. The call to
                                                                            <code>
                                                                             greater(x, 6)
                                                                            </code>
                                                                            cannot be evaluated at compile-time, so a compile error will result.
                                                                            <div class="cpp-note cpp-lightgreenbackground">
                                                                             <p class="cpp-note-title cpp-bottomline">
                                                                              Best practice
                                                                              <p>
                                                                               Use
                                                                               <code>
                                                                                consteval
                                                                               </code>
                                                                               if you have a function that must evaluate at compile-time for some reason (e.g. because it does something that can only be done at compile time).
                                                                              </p>
                                                                             </p>
                                                                            </div>
                                                                            <p>
                                                                             Perhaps surprisingly, the parameters of a consteval function are not constexpr (even though consteval functions can only be evaluated at compile-time). This decision was made for the sake of consistency.
                                                                             <p class="cpp-section cpp-topline" style="clear:both">
                                                                              Using consteval to make constexpr execute at compile-time
                                                                              <p>
                                                                               The downside of consteval functions is that such functions can’t evaluate at runtime, making them less flexible than constexpr functions, which can do either. Therefore, it would still be useful to have a convenient way to force constexpr functions to evaluate at compile-time (even when the return value is being used where a constant expression is not required), so that we could have compile-time evaluation when possible, and runtime evaluation when we can’t.
                                                                               <p>
                                                                                Consteval functions provides a way to make this happen, using a neat helper function:
                                                                                <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

// Uses abbreviated function template (C++20) and `auto` return type to make this function work with any type of value
// See 'related content' box below for more info (you don't need to know how these work to use this function)
consteval auto compileTimeEval(auto value)
{
    return value;
}

constexpr int greater(int x, int y) // function is constexpr
{
    return (x &gt; y ? x : y);
}

int main()
{
    std::cout &lt;&lt; greater(5, 6) &lt;&lt; '\n';                  // may or may not execute at compile-time
    std::cout &lt;&lt; compileTimeEval(greater(5, 6)) &lt;&lt; '\n'; // will execute at compile-time

    int x { 5 };
    std::cout &lt;&lt; greater(x, 6) &lt;&lt; '\n';                  // we can still call the constexpr version at runtime if we wish

    return 0;
}</code></pre>
                                                                                <p>
                                                                                 This works because consteval functions require constant expressions as arguments -- therefore, if we use the return value of a constexpr function as an argument to a consteval function, the constexpr function must be evaluated at compile-time! The consteval function just returns this argument as its own return value, so the caller can still use it.
                                                                                 <p>
                                                                                  Note that the consteval function returns by value. While this might be inefficient to do at runtime (if the value was some type that is expensive to copy, e.g. std::string), in a compile-time context, it doesn’t matter because the entire call to the consteval function will simply be replaced with the calculated return value.
                                                                                  <div class="cpp-note cpp-lightgraybackground">
                                                                                   <p class="cpp-note-title cpp-bottomline">
                                                                                    Related content
                                                                                    <p>
                                                                                     We cover
                                                                                     <code>
                                                                                      auto
                                                                                     </code>
                                                                                     return types in lesson
                                                                                     <a href="https://www.learncpp.com/cpp-tutorial/type-deduction-for-functions/">
                                                                                      10.9 -- Type deduction for functions
                                                                                     </a>
                                                                                     .
                                                                                     <br/>
                                                                                     We cover abbreviated function templates (
                                                                                     <code>
                                                                                      auto
                                                                                     </code>
                                                                                     parameters) in lesson
                                                                                     <a href="https://www.learncpp.com/cpp-tutorial/function-templates-with-multiple-template-types/">
                                                                                      11.8 -- Function templates with multiple template types
                                                                                     </a>
                                                                                     .
                                                                                    </p>
                                                                                   </p>
                                                                                  </div>
                                                                                  <p class="cpp-section cpp-topline" style="clear:both">
                                                                                   Constexpr/consteval functions can use non-const local variables
                                                                                   <p>
                                                                                    Within a constexpr or consteval function, we can use local variables that are not constexpr, and the value of these variables can be changed.
                                                                                    <p>
                                                                                     As a silly example:
                                                                                     <pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

consteval int doSomething(int x, int y) // function is consteval
{
    x = x + 2;       // we can modify the value of non-const function parameters

    int z { x + y }; // we can instantiate non-const local variables
    if (x &gt; y)
        z = z - 1;   // and then modify their values

    return z;
}

int main()
{
    constexpr int g { doSomething(5, 6) };
    std::cout &lt;&lt; g &lt;&lt; '\n';

    return 0;
}</code></pre>
                                                                                     <p>
                                                                                      When such functions are evaluated at compile-time, the compiler will essentially “execute” the function and return the calculated value.
                                                                                      <p class="cpp-section cpp-topline" style="clear:both">
                                                                                       Constexpr/consteval functions can use function parameters and local variables as arguments in constexpr function calls
                                                                                      </p>
                                                                                     </p>
                                                                                    </p>
                                                                                   </p>
                                                                                  </p>
                                                                                 </p>
                                                                                </p>
                                                                               </p>
                                                                              </p>
                                                                             </p>
                                                                            </p>
                                                                           </p>
                                                                          </p>
                                                                         </p>
                                                                        </p>
                                                                       </p>
                                                                      </p>
                                                                     </p>
                                                                    </p>
                                                                   </p>
                                                                  </p>
                                                                 </p>
                                                                </p>
                                                               </p>
                                                              </p>
                                                             </p>
                                                            </p>
                                                           </p>
                                                          </p>
                                                         </p>
                                                        </p>
                                                       </p>
                                                      </p>
                                                     </p>
                                                    </p>
                                                   </p>
                                                  </p>
                                                 </p>
                                                </p>
                                               </p>
                                              </p>
                                             </p>
                                            </p>
                                           </p>
                                          </p>
                                         </p>
                                        </p>
                                       </p>
                                      </p>
                                     </p>
                                    </p>
                                   </p>
                                  </p>
                                 </p>
                                </p>
                               </p>
                              </p>
                             </p>
                            </p>
                           </p>
                          </p>
                         </p>
                        </p>
                       </p>
                      </p>
                     </p>
                    </p>
                   </p>
                  </p>
                 </p>
                </p>
               </p>
              </p>
             </p>
            </p>
           </p>
          </p>
         </p>
        </p>
       </p>
      </p>
     </p>
    </p>
   </p>
  </p>
 </div>
</div>
